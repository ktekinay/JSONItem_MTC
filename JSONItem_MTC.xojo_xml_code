<?xml version="1.0" encoding="UTF-8"?>
<RBProject version="2019r3.1" FormatVersion="2" MinIDEVersion="20070100">
<block type="Module" ID="1729940940">
 <ObjName>JSONItem_MTC</ObjName>
 <ObjContainerID>0</ObjContainerID>
 <IsClass>1</IsClass>
 <ItemFlags>1</ItemFlags>
 <IsInterface>0</IsInterface>
 <Compatibility></Compatibility>
 <Method>
  <ItemName>AdvancePastWhiteSpace</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>1595070463</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Sub AdvancePastWhiteSpace(inMB As MemoryBlock, ByRef pos As Integer)</SourceLine>
   <SourceLine>dim inPtr as Ptr = inMB</SourceLine>
   <SourceLine>dim lastPos as integer = inMB.Size - 1</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>do</SourceLine>
   <SourceLine>if pos &gt; lastPos then</SourceLine>
   <SourceLine>raise new JSONException( "A parsing error occurred", 2, pos )</SourceLine>
   <SourceLine>return</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>dim thisByte as integer = inPtr.Byte( pos )</SourceLine>
   <SourceLine>select case thisByte</SourceLine>
   <SourceLine>case 9, 10, 13, 32</SourceLine>
   <SourceLine>pos = pos + 1</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>return</SourceLine>
   <SourceLine>end select</SourceLine>
   <SourceLine>loop</SourceLine>
   <SourceLine>End Sub</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>inMB As MemoryBlock, ByRef pos As Integer</ItemParams>
  <ItemResult></ItemResult>
 </Method>
 <Method>
  <ItemName>Append</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>338456575</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Sub Append(value As Variant)</SourceLine>
   <SourceLine>if not EnsureArray() then</SourceLine>
   <SourceLine>return</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Validate( value )</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>HasSetType = kHasSetArray</SourceLine>
   <SourceLine>ArrayValues.Append value</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Sub</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>0</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>value As Variant</ItemParams>
  <ItemResult></ItemResult>
 </Method>
 <Method>
  <ItemName>Child</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>1240612863</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function Child(index As Integer) As JSONItem_MTC</SourceLine>
   <SourceLine>dim r as JSONItem_MTC = self.Value( index )</SourceLine>
   <SourceLine>return r</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>0</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>index As Integer</ItemParams>
  <ItemResult>JSONItem_MTC</ItemResult>
 </Method>
 <Method>
  <ItemName>Child</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>148371455</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Sub Child(index As Integer, Assigns obj As JSONItem_MTC)</SourceLine>
   <SourceLine>self.Value( index ) = obj</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Sub</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>0</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>index As Integer, Assigns obj As JSONItem_MTC</ItemParams>
  <ItemResult></ItemResult>
 </Method>
 <Method>
  <ItemName>Child</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>1350766591</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function Child(name As String) As JSONItem_MTC</SourceLine>
   <SourceLine>dim r as JSONItem_MTC = self.Value( name )</SourceLine>
   <SourceLine>return r</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>0</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>name As String</ItemParams>
  <ItemResult>JSONItem_MTC</ItemResult>
 </Method>
 <Method>
  <ItemName>Child</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>1153255423</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Sub Child(name As String, Assigns obj As JSONItem_MTC)</SourceLine>
   <SourceLine>self.Value( name ) = obj</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Sub</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>0</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>name As String, Assigns obj As JSONItem_MTC</ItemParams>
  <ItemResult></ItemResult>
 </Method>
 <Method>
  <ItemName>Clear</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>844138495</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Sub Clear()</SourceLine>
   <SourceLine>ObjectValues = new Dictionary</SourceLine>
   <SourceLine>redim ArrayValues( -1 )</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Sub</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>0</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams></ItemParams>
  <ItemResult></ItemResult>
 </Method>
 <Method>
  <ItemName>Constructor</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>1090279423</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Sub Constructor()</SourceLine>
   <SourceLine>LoadCS = new CriticalSection</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>ObjectValues = new Dictionary</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>DecimalFormat = kDefaultDecimalFormat</SourceLine>
   <SourceLine>End Sub</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>0</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams></ItemParams>
  <ItemResult></ItemResult>
 </Method>
 <Method>
  <ItemName>Constructor</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>1303343103</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Sub Constructor(JSONString As String, isStrict As Boolean = False)</SourceLine>
   <SourceLine>self.Constructor()</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>self.Strict = isStrict</SourceLine>
   <SourceLine>self.Load JSONString</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Sub</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>0</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>JSONString As String, isStrict As Boolean = False</ItemParams>
  <ItemResult></ItemResult>
 </Method>
 <Method>
  <ItemName>DecodeString</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>1646084095</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function DecodeString(inMB As MemoryBlock, ByRef pos As Integer, current As JSONItem_MTC, outMB As MemoryBlock) As String</SourceLine>
   <SourceLine>dim lastPos as integer = inMB.Size - 1</SourceLine>
   <SourceLine>if pos &gt; lastPos then</SourceLine>
   <SourceLine>raise new JSONException( "Missing """, 7, pos + 1 )</SourceLine>
   <SourceLine>return ""</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>dim inPtr as Ptr = inMB</SourceLine>
   <SourceLine>if inPtr.Byte( pos ) &lt;&gt; kQuote then</SourceLine>
   <SourceLine>raise new JSONException( "Missing """, 7, pos + 1 )</SourceLine>
   <SourceLine>return ""</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if outMB.Size &lt; inMB.Size then</SourceLine>
   <SourceLine>outMB.Size = inMB.Size</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>dim outPtr as Ptr = outMB</SourceLine>
   <SourceLine>dim outIndex as integer</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>pos = pos + 1</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>dim flushStart as integer = pos</SourceLine>
   <SourceLine>dim flushEnd as integer = -1</SourceLine>
   <SourceLine>dim hasBackSlash as boolean</SourceLine>
   <SourceLine>dim surrogatePairFirstHalf as integer</SourceLine>
   <SourceLine>dim surrogatePairLastHalf as integer</SourceLine>
   <SourceLine>dim expectingSurrogate as boolean</SourceLine>
   <SourceLine>dim insertCodepoint as boolean</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>do</SourceLine>
   <SourceLine>if pos &gt; lastPos then</SourceLine>
   <SourceLine>dim msg as string = if( current.IsArray, "Missing , or ]", "Missing , or }" )</SourceLine>
   <SourceLine>raise new JSONException( msg, 6, pos )</SourceLine>
   <SourceLine>return ""</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if expectingSurrogate and ( inPtr.Byte( pos ) &lt;&gt; kBackSlash or ( pos + 1 ) &gt; lastPos or inPtr.Byte( pos + 1 ) &lt;&gt; 117 ) then</SourceLine>
   <SourceLine>raise new JSONException( "Improperly formed JSON string", 0 )</SourceLine>
   <SourceLine>return ""</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>dim thisByte as integer = inPtr.Byte( pos )</SourceLine>
   <SourceLine>select case thisByte</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>case kBackSlash</SourceLine>
   <SourceLine>hasBackSlash = true</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if flushEnd &lt;&gt; -1 then</SourceLine>
   <SourceLine>dim flushLen as integer = flushEnd - flushStart + 1</SourceLine>
   <SourceLine>outMB.StringValue( outIndex, flushLen ) = inMB.StringValue( flushStart, flushLen )</SourceLine>
   <SourceLine>outIndex = outIndex + flushLen</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>pos = pos + 1</SourceLine>
   <SourceLine>if pos &gt; lastPos then</SourceLine>
   <SourceLine>continue do</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>thisByte = inPtr.Byte( pos )</SourceLine>
   <SourceLine>if Strict and thisByte &lt; 32 then</SourceLine>
   <SourceLine>continue do // Deal on the next pass</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>select case thisByte</SourceLine>
   <SourceLine>case 114 // r</SourceLine>
   <SourceLine>outPtr.Byte( outIndex ) = 13</SourceLine>
   <SourceLine>outIndex = outIndex + 1</SourceLine>
   <SourceLine>pos = pos + 1</SourceLine>
   <SourceLine>case 116 // t</SourceLine>
   <SourceLine>outPtr.Byte( outIndex ) = 9</SourceLine>
   <SourceLine>outIndex = outIndex + 1</SourceLine>
   <SourceLine>pos = pos + 1</SourceLine>
   <SourceLine>case 110 // n</SourceLine>
   <SourceLine>outPtr.Byte( outIndex ) = 10</SourceLine>
   <SourceLine>outIndex = outIndex + 1</SourceLine>
   <SourceLine>pos = pos + 1</SourceLine>
   <SourceLine>case 98 // b</SourceLine>
   <SourceLine>outPtr.Byte( outIndex ) = 8</SourceLine>
   <SourceLine>outIndex = outIndex + 1</SourceLine>
   <SourceLine>pos = pos + 1</SourceLine>
   <SourceLine>case 102 // f</SourceLine>
   <SourceLine>outPtr.Byte( outIndex ) = 12</SourceLine>
   <SourceLine>outIndex = outIndex + 1</SourceLine>
   <SourceLine>pos = pos + 1</SourceLine>
   <SourceLine>case 117 // u</SourceLine>
   <SourceLine>if ( pos + 5 ) &gt; lastPos then</SourceLine>
   <SourceLine>raise new JSONException( "Improperly formed JSON string", 0 )</SourceLine>
   <SourceLine>return ""</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>dim codepoint as integer</SourceLine>
   <SourceLine>for byteAdder as integer = 1 to 4</SourceLine>
   <SourceLine>dim hexDigit as integer = inPtr.Byte( pos + byteAdder )</SourceLine>
   <SourceLine>select case hexDigit</SourceLine>
   <SourceLine>case 48 to 57 // 0 - 9</SourceLine>
   <SourceLine>codepoint = ( codepoint * 16 ) + ( hexDigit - 48 )</SourceLine>
   <SourceLine>case 65 to 70 // A - F</SourceLine>
   <SourceLine>codepoint = ( codepoint * 16 ) + ( hexDigit - 55 )</SourceLine>
   <SourceLine>case 97 to 102 // a - f</SourceLine>
   <SourceLine>codepoint = ( codepoint * 16 ) + ( hexDigit - 87 )</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>raise new JSONException( "Illegal value", 10, pos )</SourceLine>
   <SourceLine>return ""</SourceLine>
   <SourceLine>end select</SourceLine>
   <SourceLine>next</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// See if this is part of a surrogate pair</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>if expectingSurrogate then</SourceLine>
   <SourceLine>if codepoint &lt; &amp;hDC00 or codepoint &gt; &amp;hDFFF then</SourceLine>
   <SourceLine>raise new JSONException( "Invalid codepoint", 10, pos )</SourceLine>
   <SourceLine>return ""</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// surrogatePairFirstHalf holds the first 10 bits, this codepoint holds the last 10</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>surrogatePairLastHalf = codepoint</SourceLine>
   <SourceLine>codepoint = Bitwise.ShiftLeft( surrogatePairFirstHalf - &amp;hD800, 10, 20 ) + ( surrogatePairLastHalf - &amp;hDC00 ) + &amp;h10000</SourceLine>
   <SourceLine>insertCodepoint = true</SourceLine>
   <SourceLine>expectingSurrogate = false</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>elseif codepoint &lt; 128 then</SourceLine>
   <SourceLine>outPtr.Byte( outIndex ) = codepoint</SourceLine>
   <SourceLine>outIndex = outIndex + 1</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>elseif codepoint &lt; &amp;hD800 or codepoint &gt; &amp;hDFFF then</SourceLine>
   <SourceLine>insertCodepoint = True</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>elseif codepoint &lt; &amp;hDC00 then // Surrogate pair</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>surrogatePairFirstHalf = codepoint</SourceLine>
   <SourceLine>expectingSurrogate = true</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>else // It's some codepoint that shouldn't be here</SourceLine>
   <SourceLine>raise new JSONException( "Invalid codepoint", 10, pos )</SourceLine>
   <SourceLine>return ""</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if insertCodepoint then</SourceLine>
   <SourceLine>if codepoint &gt; &amp;b1111111111111111 then // Four bytes</SourceLine>
   <SourceLine>outPtr.Byte( outIndex ) = &amp;b11110000 or Bitwise.ShiftRight( codepoint, 18, 21 )</SourceLine>
   <SourceLine>outPtr.Byte( outIndex + 1 ) = &amp;b10000000 or ( Bitwise.ShiftRight( codepoint, 12, 21 ) and &amp;b111111 )</SourceLine>
   <SourceLine>outPtr.Byte( outIndex + 2 ) = &amp;b10000000 or ( Bitwise.ShiftRight( codepoint, 6, 21 ) and &amp;b111111 )</SourceLine>
   <SourceLine>outPtr.Byte( outIndex + 3 ) = &amp;b10000000 or ( codepoint and &amp;b111111 )</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>outIndex = outIndex + 4</SourceLine>
   <SourceLine>elseif codepoint &gt; &amp;b11111111111  then // Three bytes</SourceLine>
   <SourceLine>outPtr.Byte( outIndex ) = &amp;b11100000 or Bitwise.ShiftRight( codepoint, 12, 16 )</SourceLine>
   <SourceLine>outPtr.Byte( outIndex + 1 ) = &amp;b10000000 or ( BitWise.ShiftRight( codepoint, 6, 16 ) and &amp;b111111 )</SourceLine>
   <SourceLine>outPtr.Byte( outIndex + 2 ) = &amp;b10000000 or ( codepoint and &amp;b111111 )</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>outIndex = outIndex + 3</SourceLine>
   <SourceLine>else // two bytes</SourceLine>
   <SourceLine>outPtr.Byte( outIndex ) = &amp;b11000000 or Bitwise.ShiftRight( codepoint, 6, 11 )</SourceLine>
   <SourceLine>outPtr.Byte( outIndex + 1 ) = &amp;b10000000 or ( codepoint and &amp;b111111 )</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>outIndex = outIndex + 2</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>insertCodepoint = false</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>pos = pos + 5</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>else // Some random escaped character</SourceLine>
   <SourceLine>if Strict then</SourceLine>
   <SourceLine>raise new JSONException( "Illegal Character", 9, pos + 1 )</SourceLine>
   <SourceLine>return ""</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>outPtr.Byte( outIndex ) = inPtr.Byte( pos )</SourceLine>
   <SourceLine>outIndex = outIndex + 1</SourceLine>
   <SourceLine>pos = pos + 1</SourceLine>
   <SourceLine>end select</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>flushStart = pos</SourceLine>
   <SourceLine>flushEnd = -1</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>case kQuote // End</SourceLine>
   <SourceLine>pos = pos + 1</SourceLine>
   <SourceLine>exit </SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>if self.Strict and thisByte &lt; 32 then</SourceLine>
   <SourceLine>raise new JSONException( "Illegal Character", 9, pos + 1 )</SourceLine>
   <SourceLine>return ""</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>flushEnd = pos</SourceLine>
   <SourceLine>pos = pos + 1</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>end select</SourceLine>
   <SourceLine>loop</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if hasBackSlash and flushEnd &lt;&gt; -1 then</SourceLine>
   <SourceLine>dim flushLen as integer = flushEnd - flushStart + 1</SourceLine>
   <SourceLine>outMB.StringValue( outIndex, flushLen ) = inMB.StringValue( flushStart, flushLen )</SourceLine>
   <SourceLine>outIndex = outIndex + flushLen</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>dim r as string </SourceLine>
   <SourceLine>if hasBackSlash then</SourceLine>
   <SourceLine>r = outMB.StringValue( 0, outIndex )</SourceLine>
   <SourceLine>elseif flushEnd &lt;&gt; -1 then</SourceLine>
   <SourceLine>r = inMB.StringValue( flushStart, flushEnd - flushStart + 1 )</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>r = r.DefineEncoding( Encodings.UTF8 )</SourceLine>
   <SourceLine>return r</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>inMB As MemoryBlock, ByRef pos As Integer, current As JSONItem_MTC, outMB As MemoryBlock</ItemParams>
  <ItemResult>String</ItemResult>
 </Method>
 <Method>
  <ItemName>DecodeValue</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>1663215615</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function DecodeValue(inMB As MemoryBlock, ByRef pos As Integer, current As JSONItem_MTC, outMB As MemoryBlock) As Variant</SourceLine>
   <SourceLine>static trueValue as Int32</SourceLine>
   <SourceLine>if trueValue = 0 then</SourceLine>
   <SourceLine>dim mb as MemoryBlock = "true"</SourceLine>
   <SourceLine>mb.LittleEndian = inMB.LittleEndian</SourceLine>
   <SourceLine>trueValue = mb.Int32Value( 0 )</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>static nullValue as Int32</SourceLine>
   <SourceLine>if nullValue = 0 then</SourceLine>
   <SourceLine>dim mb as MemoryBlock = "null"</SourceLine>
   <SourceLine>mb.LittleEndian = inMB.LittleEndian</SourceLine>
   <SourceLine>nullValue = mb.Int32Value( 0 )</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>static falsValue as Int32</SourceLine>
   <SourceLine>if falsValue = 0 then</SourceLine>
   <SourceLine>dim mb as MemoryBlock = "fals"</SourceLine>
   <SourceLine>mb.LittleEndian = inMB.LittleEndian</SourceLine>
   <SourceLine>falsValue = mb.Int32Value( 0 )</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>dim lastPos as integer = inMB.Size - 1</SourceLine>
   <SourceLine>if pos &gt; lastPos then</SourceLine>
   <SourceLine>raise new JSONException( "A parsing error occurred", 2, pos + 1 )</SourceLine>
   <SourceLine>return nil</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>dim inPtr as Ptr = inMB</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>dim thisByte as integer = inPtr.Byte( pos )</SourceLine>
   <SourceLine>if thisByte = kQuote then</SourceLine>
   <SourceLine>return DecodeString( inMB, pos, current, outMB )</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>elseif thisByte = kOpenCurlyBrace then</SourceLine>
   <SourceLine>dim child as new JSONItem_MTC</SourceLine>
   <SourceLine>child.HasSetType = kHasSetObject</SourceLine>
   <SourceLine>pos = pos + 1</SourceLine>
   <SourceLine>return child</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>elseif thisByte = kOpenSquareBracket then</SourceLine>
   <SourceLine>dim child as new JSONItem_MTC</SourceLine>
   <SourceLine>child.HasSetType = kHasSetArray</SourceLine>
   <SourceLine>pos = pos + 1</SourceLine>
   <SourceLine>return child</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Look for the next ender</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>dim startPos as integer = pos</SourceLine>
   <SourceLine>dim endPos as integer = pos + 1</SourceLine>
   <SourceLine>do</SourceLine>
   <SourceLine>if endPos &gt; lastPos then</SourceLine>
   <SourceLine>dim msg as string = if( current.IsArray, "Missing , or ]", "Missing , or }" )</SourceLine>
   <SourceLine>raise new JSONException( msg, 6, endPos + 1 )</SourceLine>
   <SourceLine>return nil</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>thisByte = inPtr.Byte( endPos )</SourceLine>
   <SourceLine>if thisByte &lt; 33 then</SourceLine>
   <SourceLine>exit do</SourceLine>
   <SourceLine>elseif thisByte = kComma then</SourceLine>
   <SourceLine>exit do</SourceLine>
   <SourceLine>elseif thisByte = kCloseCurlyBrace or thisByte = kCloseSquareBracket then</SourceLine>
   <SourceLine>exit do</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>endPos = endPos + 1</SourceLine>
   <SourceLine>loop</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>pos = endPos</SourceLine>
   <SourceLine>endPos = endPos - 1</SourceLine>
   <SourceLine>dim valueLen as integer = endPos - startPos + 1</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>dim value as variant</SourceLine>
   <SourceLine>dim keepChecking as boolean = valueLen &lt;&gt; 0</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>dim firstByte as integer = inPtr.Byte( startPos )</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// See if it's true, false, or null first</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>if keepChecking and valueLen = 5 then // false?</SourceLine>
   <SourceLine>if firstByte = 102 and inPtr.Byte( startPos + 4 ) = 101 and inMB.Int32Value( startPos ) = falsValue then</SourceLine>
   <SourceLine>value = false</SourceLine>
   <SourceLine>keepChecking = false</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if keepChecking and valueLen = 4 then // true or null?</SourceLine>
   <SourceLine>if  firstByte = 116 and inMB.Int32Value( startPos ) = trueValue then</SourceLine>
   <SourceLine>value = true</SourceLine>
   <SourceLine>keepChecking = false</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if keepChecking and firstByte = 110 and inMB.Int32Value( startPos ) = nullValue then</SourceLine>
   <SourceLine>value = nil</SourceLine>
   <SourceLine>keepChecking = false</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// Is it an number?</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>if keepChecking and valueLen = 1 and firstByte &gt;= 48 and firstByte &lt;= 57 then // Single digit</SourceLine>
   <SourceLine>value = firstByte - 48</SourceLine>
   <SourceLine>keepChecking = false</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if keepChecking then </SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>//  Only send it to ParseNumber if it's not Strict, or if the firstByte meets strict criteria</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>if not Strict or ( firstByte = kHyphen or ( firstByte &gt;= 48 and firstByte &lt;= 57 ) ) then</SourceLine>
   <SourceLine>if ParseNumber( inMB, startPos, endPos, value ) then</SourceLine>
   <SourceLine>keepChecking = false</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// Hail Mary</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>if keepChecking and not Strict then</SourceLine>
   <SourceLine>keepChecking = false</SourceLine>
   <SourceLine>dim valueString as string = inMB.StringValue( startPos, valueLen ).DefineEncoding( Encodings.UTF8 )</SourceLine>
   <SourceLine>if valueString = "true" then</SourceLine>
   <SourceLine>value = true</SourceLine>
   <SourceLine>elseif valueString = "false" then</SourceLine>
   <SourceLine>value = false</SourceLine>
   <SourceLine>elseif valueString = "null" then</SourceLine>
   <SourceLine>value = nil</SourceLine>
   <SourceLine>elseif IsNumeric( valueString ) then</SourceLine>
   <SourceLine>value = val( valueString )</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>keepChecking = true</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if keepChecking then // Never found it</SourceLine>
   <SourceLine>raise new JSONException( "Illegal Value", 10, startPos )</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>return value</SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>inMB As MemoryBlock, ByRef pos As Integer, current As JSONItem_MTC, outMB As MemoryBlock</ItemParams>
  <ItemResult>Variant</ItemResult>
 </Method>
 <Method>
  <ItemName>EncodeString</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>1035366399</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Sub EncodeString(s As String, settings As JSONItem_MTC, outMBs() As MemoryBlock, ByRef outIndex As Integer, inMB As MemoryBlock)</SourceLine>
   <SourceLine>// Encodes a string for output during ToString.</SourceLine>
   <SourceLine>// Honors the EncodeUnicode setting, but some characters must ALWAYS be encoded for </SourceLine>
   <SourceLine>// Javascript compatibility. These are</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>//  chr 127</SourceLine>
   <SourceLine>//  &amp;h00ad</SourceLine>
   <SourceLine>//  &amp;h0600 - &amp;h0604</SourceLine>
   <SourceLine>//  &amp;h070f</SourceLine>
   <SourceLine>//  &amp;h17b4 - &amp;h17b5</SourceLine>
   <SourceLine>//  &amp;h200c - &amp;h200f</SourceLine>
   <SourceLine>//  &amp;h2028 - &amp;h202f</SourceLine>
   <SourceLine>//  &amp;h2060 - &amp;h206f</SourceLine>
   <SourceLine>//  &amp;hfeff</SourceLine>
   <SourceLine>//  &amp;hfff0 - &amp;hffff</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>static alwaysEncode() as integer = Array( _</SourceLine>
   <SourceLine>127, &amp;hAD, _</SourceLine>
   <SourceLine>&amp;h600, &amp;h601, &amp;h602, &amp;h603, &amp;h604, _</SourceLine>
   <SourceLine>&amp;h70F, _</SourceLine>
   <SourceLine>&amp;h17B4, &amp;h17B5, _</SourceLine>
   <SourceLine>&amp;h200C, &amp;h200D, &amp;h200E, &amp;h200F, _</SourceLine>
   <SourceLine>&amp;h2028, &amp;h2029, &amp;h202A, &amp;h202B, &amp;h202C, &amp;h202D, &amp;h202E, &amp;h202F, _</SourceLine>
   <SourceLine>&amp;h2060, &amp;h2061, &amp;h2062, &amp;h2063, &amp;h2064, &amp;h2065, &amp;h2066, &amp;h2067, &amp;h2068, &amp;h2069, _</SourceLine>
   <SourceLine>&amp;h206A, &amp;h206B, &amp;h206C, &amp;h206D, &amp;h206E, &amp;h206F, _</SourceLine>
   <SourceLine>&amp;hFEFF, _</SourceLine>
   <SourceLine>&amp;hFFF0, &amp;hFFF1, &amp;hFFF2, &amp;hFFF3, &amp;hFFF4, &amp;hFFF5, &amp;hFFF6, &amp;hFFF7, &amp;hfff8, &amp;hFFF9, _</SourceLine>
   <SourceLine>&amp;hFFFA, &amp;hFFFB, &amp;hFFFC, &amp;hFFFD, &amp;hFFFE, &amp;hFFFF _</SourceLine>
   <SourceLine>)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>const kByteBuffer = 13 // Most an encoding can use plus the trailing quote</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>dim outMB as MemoryBlock = outMBs( outMBs.Ubound )</SourceLine>
   <SourceLine>dim outSize as integer = outMB.Size</SourceLine>
   <SourceLine>if outIndex &gt; ( outSize - kByteBuffer ) then</SourceLine>
   <SourceLine>outMB = AppendOutMB( outMBs, outIndex )</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>dim outPtr as Ptr = outMB</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>outPtr.Byte( outIndex ) = kQuote</SourceLine>
   <SourceLine>outIndex = outIndex + 1</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if s = "" then</SourceLine>
   <SourceLine>outPtr.Byte( outIndex ) = kQuote</SourceLine>
   <SourceLine>outIndex = outIndex + 1</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>return</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>s = s.ConvertEncoding( Encodings.UTF8 )</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>dim inSize as integer = s.LenB</SourceLine>
   <SourceLine>if inMB.Size &lt; inSize then</SourceLine>
   <SourceLine>inMB.Size = inSize</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>inMB.StringValue( 0, inSize ) = s</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>dim inPtr as Ptr = inMB</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>dim lastIndex as integer = inSize - 1</SourceLine>
   <SourceLine>dim inIndex as integer = -1</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>dim encodeUnicode as EncodeType = settings.EncodeUnicode</SourceLine>
   <SourceLine>dim escapeSlashes as boolean = settings.EscapeSlashes</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>do</SourceLine>
   <SourceLine>inIndex = inIndex + 1</SourceLine>
   <SourceLine>if inIndex &gt; lastIndex then</SourceLine>
   <SourceLine>exit do</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if outIndex &gt; ( outSize - kByteBuffer ) then</SourceLine>
   <SourceLine>outMB = AppendOutMB( outMBs, outIndex )</SourceLine>
   <SourceLine>outSize = outMB.Size</SourceLine>
   <SourceLine>outPtr = outMB</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>dim thisByte as byte = inPtr.Byte( inIndex )</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if thisByte = 34 or thisByte = kBackSlash then // quote or backslash</SourceLine>
   <SourceLine>outPtr.Byte( outIndex ) = kBackSlash</SourceLine>
   <SourceLine>outPtr.Byte( outIndex + 1 ) = thisByte</SourceLine>
   <SourceLine>outIndex = outIndex + 2</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>elseif thisByte = 47 then // slash</SourceLine>
   <SourceLine>if escapeSlashes then</SourceLine>
   <SourceLine>outPtr.Byte( outIndex ) = kBackSlash</SourceLine>
   <SourceLine>outPtr.Byte( outIndex + 1 ) = thisByte</SourceLine>
   <SourceLine>outIndex = outIndex + 2</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>outPtr.Byte( outIndex ) = thisByte</SourceLine>
   <SourceLine>outIndex = outIndex + 1</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>elseif thisByte = 8 then // backspace</SourceLine>
   <SourceLine>outPtr.Byte( outIndex ) = kBackSlash</SourceLine>
   <SourceLine>outPtr.Byte( outIndex + 1 ) = 98 // b</SourceLine>
   <SourceLine>outIndex = outIndex + 2</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>elseif thisByte = 9 then // tab</SourceLine>
   <SourceLine>outPtr.Byte( outIndex ) = kBackSlash</SourceLine>
   <SourceLine>outPtr.Byte( outIndex + 1 ) = 116 // t</SourceLine>
   <SourceLine>outIndex = outIndex + 2</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>elseif thisByte = 10 then // linefeed</SourceLine>
   <SourceLine>outPtr.Byte( outIndex ) = kBackSlash</SourceLine>
   <SourceLine>outPtr.Byte( outIndex + 1 ) = 110 // n</SourceLine>
   <SourceLine>outIndex = outIndex + 2</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>elseif thisByte = 12 then // formfeed</SourceLine>
   <SourceLine>outPtr.Byte( outIndex ) = kBackSlash</SourceLine>
   <SourceLine>outPtr.Byte( outIndex + 1 ) = 102 // f</SourceLine>
   <SourceLine>outIndex = outIndex + 2</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>elseif thisByte = 13 then // return</SourceLine>
   <SourceLine>outPtr.Byte( outIndex ) = kBackSlash</SourceLine>
   <SourceLine>outPtr.Byte( outIndex + 1 ) = 114 // r</SourceLine>
   <SourceLine>outIndex = outIndex + 2</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>elseif thisByte &lt; 32 then // control character</SourceLine>
   <SourceLine>outPtr.Byte( outIndex ) = kBackSlash</SourceLine>
   <SourceLine>outPtr.Byte( outIndex + 1 ) = 117 // u</SourceLine>
   <SourceLine>dim insertValue as string = Right( "000" + hex( thisByte ), 4 )</SourceLine>
   <SourceLine>outMB.StringValue( outIndex + 2, 4 ) = insertValue</SourceLine>
   <SourceLine>outIndex = outIndex + 6</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>elseif thisByte &gt; 127 and thisByte &lt; 192 then // Continuation byte that wasn't encoded, so just add it</SourceLine>
   <SourceLine>outPtr.Byte( outIndex ) = thisByte</SourceLine>
   <SourceLine>outIndex = outIndex + 1</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>elseif encodeUnicode &lt;&gt; EncodeType.None and ( thisByte = 127 or thisByte &gt;= 192 ) then // Leading byte</SourceLine>
   <SourceLine>dim codepoint as integer</SourceLine>
   <SourceLine>dim byteLength as integer</SourceLine>
   <SourceLine>if thisByte &gt;= 240 then</SourceLine>
   <SourceLine>byteLength = 4</SourceLine>
   <SourceLine>codepoint = Bitwise.ShiftLeft( thisByte and &amp;b00000111, 18, 21 )</SourceLine>
   <SourceLine>codepoint = codepoint + ( Bitwise.ShiftLeft( inPtr.Byte( inIndex + 1 ) and &amp;b00111111, 12, 21 ) )</SourceLine>
   <SourceLine>codepoint = codepoint + ( Bitwise.ShiftLeft( inPtr.Byte( inIndex + 2 ) and &amp;b00111111 , 6, 21 ) )</SourceLine>
   <SourceLine>codepoint = codepoint + ( inPtr.Byte( inIndex + 3 ) and &amp;b00111111 )</SourceLine>
   <SourceLine>elseif thisByte &gt;= 224 then</SourceLine>
   <SourceLine>byteLength = 3</SourceLine>
   <SourceLine>codepoint = Bitwise.ShiftLeft( thisByte and &amp;b00001111, 12, 18 )</SourceLine>
   <SourceLine>codepoint = codepoint + ( Bitwise.ShiftLeft( inPtr.Byte( inIndex + 1 ) and &amp;b00111111, 6, 18 ) )</SourceLine>
   <SourceLine>codepoint = codepoint + ( inPtr.Byte( inIndex + 2 ) and &amp;b00111111 )</SourceLine>
   <SourceLine>elseif thisByte &gt;= 192 then</SourceLine>
   <SourceLine>byteLength = 2</SourceLine>
   <SourceLine>codepoint = Bitwise.ShiftLeft( thisByte and &amp;b00011111, 6, 18 )</SourceLine>
   <SourceLine>codepoint = codepoint + ( inPtr.Byte( inIndex + 1 ) and &amp;b00111111 )</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>byteLength = 1</SourceLine>
   <SourceLine>codepoint = thisByte</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// See if we have to use a surrogate pair</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>if codepoint &gt; &amp;hFFFF and encodeUnicode = EncodeType.All then</SourceLine>
   <SourceLine>codepoint = codepoint - &amp;h10000</SourceLine>
   <SourceLine>dim surrogateFirst as integer = &amp;hD800 + Bitwise.ShiftRight( codepoint, 10, 21 )</SourceLine>
   <SourceLine>dim surrogateLast as integer = &amp;hDC00 + ( codepoint and &amp;b1111111111 )</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>outPtr.Byte( outIndex ) = kBackSlash</SourceLine>
   <SourceLine>outPtr.Byte( outIndex + 1 ) = 117 // u</SourceLine>
   <SourceLine>EncodeCodepoint( surrogateFirst, outPtr, outIndex + 2 )</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>outPtr.Byte( outIndex + 6 ) = kBackSlash</SourceLine>
   <SourceLine>outPtr.Byte( outIndex + 7 ) = 117 // u</SourceLine>
   <SourceLine>EncodeCodepoint( surrogateLast, outPtr, outIndex + 8 )</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>outIndex = outIndex + 12</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>elseif codepoint &lt;= &amp;hFFFF and ( encodeUnicode = EncodeType.All or alwaysEncode.IndexOf( codepoint ) &lt;&gt; -1 ) then</SourceLine>
   <SourceLine>outPtr.Byte( outIndex ) = kBackSlash</SourceLine>
   <SourceLine>outPtr.Byte( outIndex + 1 ) = 117 // u</SourceLine>
   <SourceLine>EncodeCodepoint( codepoint, outPtr, outIndex + 2 )</SourceLine>
   <SourceLine>outIndex = outIndex + 6</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>outPtr.Byte( outIndex ) = thisByte</SourceLine>
   <SourceLine>outIndex = outIndex + 1</SourceLine>
   <SourceLine>byteLength = 1 // Doesn't matter what it really is, only need to advance one byte</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>inIndex = inIndex + byteLength - 1</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>else // thisByte &gt; 31 and thisByte &lt; 127  </SourceLine>
   <SourceLine>outPtr.Byte( outIndex ) = thisByte</SourceLine>
   <SourceLine>outIndex = outIndex + 1</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>loop</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>outPtr.Byte( outIndex ) = kQuote</SourceLine>
   <SourceLine>outIndex = outIndex + 1</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Sub</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>s As String, settings As JSONItem_MTC, outMBs() As MemoryBlock, ByRef outIndex As Integer, inMB As MemoryBlock</ItemParams>
  <ItemResult></ItemResult>
 </Method>
 <Method>
  <ItemName>EncodeValue</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>60155903</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Sub EncodeValue(value As Variant, settings As JSONItem_MTC, level As Integer, outMBs() As MemoryBlock, ByRef outIndex As Integer, inMB As MemoryBlock)</SourceLine>
   <SourceLine>if value IsA JSONItem_MTC then</SourceLine>
   <SourceLine>JSONItem_MTC( value ).Serialize( outMBs, outIndex, settings, level, inMB )</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>elseif value IsA Dictionary then</SourceLine>
   <SourceLine>dim child as JSONItem_MTC = Dictionary( value )</SourceLine>
   <SourceLine>child.Serialize( outMBs, outIndex, settings, level, inMB )</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>elseif value.Type = Variant.TypeString or value.Type = Variant.TypeCString or _</SourceLine>
   <SourceLine>value.Type = Variant.TypePString then</SourceLine>
   <SourceLine>EncodeString( value.StringValue, settings, outMBs, outIndex, inMB )</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>elseif value.Type = Variant.TypeText then</SourceLine>
   <SourceLine>dim t as Text = value.TextValue</SourceLine>
   <SourceLine>dim s as string = t</SourceLine>
   <SourceLine>EncodeString( s, settings, outMBs, outIndex, inMB )</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>dim insert as string</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if value.Type = Variant.TypeDouble or value.Type = Variant.TypeSingle or _</SourceLine>
   <SourceLine>value.Type = Variant.TypeCurrency then</SourceLine>
   <SourceLine>dim s as string = value.StringValue</SourceLine>
   <SourceLine>if s.InStr( "inf" ) &lt;&gt; 0 then</SourceLine>
   <SourceLine>if settings.Strict then</SourceLine>
   <SourceLine>raise new JSONException( "Illegal Value 'inf'", 10 )</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>insert = "inf"</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>elseif s.InStr( "nan" ) &lt;&gt; 0 then </SourceLine>
   <SourceLine>if settings.Strict then</SourceLine>
   <SourceLine>raise new JSONException( "Illegal Value 'nan'", 10 )</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>insert = "nan"</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>insert = Format( value, settings.DecimalFormat )</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>elseif value.Type = Variant.TypeNil then</SourceLine>
   <SourceLine>insert = "null"</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>insert = value.StringValue.Lowercase</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>dim insertLen as integer = insert.LenB</SourceLine>
   <SourceLine>dim outMB as MemoryBlock = outMBs( outMBs.Ubound )</SourceLine>
   <SourceLine>dim outSize as integer = outMB.Size</SourceLine>
   <SourceLine>if outIndex &gt; ( outSize - insertLen ) then</SourceLine>
   <SourceLine>outMB = AppendOutMB( outMBs, outIndex )</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>outMB.StringValue( outIndex, insertLen ) = insert</SourceLine>
   <SourceLine>outIndex = outIndex + insertLen</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>End Sub</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>value As Variant, settings As JSONItem_MTC, level As Integer, outMBs() As MemoryBlock, ByRef outIndex As Integer, inMB As MemoryBlock</ItemParams>
  <ItemResult></ItemResult>
 </Method>
 <Method>
  <ItemName>EnsureArray</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>53555199</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function EnsureArray() As Boolean</SourceLine>
   <SourceLine>if HasSetType &lt;&gt; kHasSetObject then</SourceLine>
   <SourceLine>return true</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>raise new JSONException( "This JSONItem_MTC is an object", 13 )</SourceLine>
   <SourceLine>return false</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams></ItemParams>
  <ItemResult>Boolean</ItemResult>
 </Method>
 <Method>
  <ItemName>EnsureObject</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>1343256575</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function EnsureObject() As Boolean</SourceLine>
   <SourceLine>if HasSetType &lt;&gt; kHasSetArray then</SourceLine>
   <SourceLine>return true</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>raise new JSONException( "This JSONItem_MTC is an array", 13 )</SourceLine>
   <SourceLine>return false</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams></ItemParams>
  <ItemResult>Boolean</ItemResult>
 </Method>
 <Method>
  <ItemName>HasName</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>458487807</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function HasName(name As String) As Boolean</SourceLine>
   <SourceLine>if not EnsureObject() then</SourceLine>
   <SourceLine>return false</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>HasSetType = kHasSetObject</SourceLine>
   <SourceLine>dim key as string = NameToKey( name )</SourceLine>
   <SourceLine>return ObjectValues.HasKey( key )</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>0</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>name As String</ItemParams>
  <ItemResult>Boolean</ItemResult>
 </Method>
 <Method>
  <ItemName>Insert</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>1100691455</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Sub Insert(index As Integer, value As Variant)</SourceLine>
   <SourceLine>if not EnsureArray() then</SourceLine>
   <SourceLine>return</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>HasSetType = kHasSetArray</SourceLine>
   <SourceLine>ArrayValues.Insert( index, value )</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Sub</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>0</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>index As Integer, value As Variant</ItemParams>
  <ItemResult></ItemResult>
 </Method>
 <Method>
  <ItemName>Load</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>646508543</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Sub Load(JSONString As String)</SourceLine>
   <SourceLine>const kNeverStarted = -1000</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>dim originalSetType as integer = kNeverStarted</SourceLine>
   <SourceLine>dim originalValue as variant</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if not LoadCS.TryEnter then</SourceLine>
   <SourceLine>raise new JSONException( "This object is currently loading", 0 )</SourceLine>
   <SourceLine>return</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>JSONString = JSONStringToUTF8( JSONString ).RTrim</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if JSONString = "" then</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Do nothing</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>mIsLoading = true</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// Save original values</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>originalSetType = self.HasSetType</SourceLine>
   <SourceLine>if originalSetType = kHasSetArray then</SourceLine>
   <SourceLine>dim values() as variant</SourceLine>
   <SourceLine>redim values( ArrayValues.Ubound )</SourceLine>
   <SourceLine>for i as integer = 0  to ArrayValues.Ubound</SourceLine>
   <SourceLine>values( i ) = ArrayValues( i )</SourceLine>
   <SourceLine>next i</SourceLine>
   <SourceLine>originalValue = values</SourceLine>
   <SourceLine>elseif originalSetType = kHasSetObject then</SourceLine>
   <SourceLine>dim d as new Dictionary</SourceLine>
   <SourceLine>dim keys() as Variant = ObjectValues.Keys</SourceLine>
   <SourceLine>for i as integer = 0 to keys.Ubound</SourceLine>
   <SourceLine>dim k as variant = keys( i )</SourceLine>
   <SourceLine>d.Value( k ) = ObjectValues.Value( k )</SourceLine>
   <SourceLine>next i</SourceLine>
   <SourceLine>originalValue = d</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>dim inMB as MemoryBlock = JSONString</SourceLine>
   <SourceLine>dim pos as integer</SourceLine>
   <SourceLine>dim inPtr as Ptr = inMB</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if inPtr.Byte( pos ) &lt; 33 then</SourceLine>
   <SourceLine>self.AdvancePastWhiteSpace( inMB, pos )</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>dim proceed as boolean = true</SourceLine>
   <SourceLine>if inPtr.Byte( pos ) = kOpenSquareBracket then</SourceLine>
   <SourceLine>if IsObject then</SourceLine>
   <SourceLine>// Do nothing</SourceLine>
   <SourceLine>proceed = false</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>HasSetType = kHasSetArray</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>elseif inPtr.Byte( pos ) = kOpenCurlyBrace then</SourceLine>
   <SourceLine>if IsArray then</SourceLine>
   <SourceLine>// Do nothing</SourceLine>
   <SourceLine>proceed = false</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>HasSetType = kHasSetObject</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>elseif inPtr.Byte( pos ) &lt;&gt; kOpenCurlyBrace and inPtr.Byte( pos ) &lt;&gt; kOpenSquareBracket then</SourceLine>
   <SourceLine>raise new JSONException( "Parse Error: Expecting '{' or '['", 1 )</SourceLine>
   <SourceLine>return</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if proceed then</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>dim outMB as new MemoryBlock( 1024 )</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>pos = pos + 1</SourceLine>
   <SourceLine>dim stack() as JSONItem_MTC </SourceLine>
   <SourceLine>dim current as JSONItem_MTC = self</SourceLine>
   <SourceLine>dim lastIndex as integer = inMB.Size - 1</SourceLine>
   <SourceLine>do</SourceLine>
   <SourceLine>if current.IsArray then</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if pos &lt;= lastIndex and inPtr.Byte( pos ) &lt; 33 then</SourceLine>
   <SourceLine>self.AdvancePastWhiteSpace( inMB, pos )</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if inPtr.Byte( pos ) = kCloseSquareBracket then // Empty array</SourceLine>
   <SourceLine>if stack.Ubound &lt;&gt; -1 then</SourceLine>
   <SourceLine>current = stack.Pop</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>current = nil</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>pos = pos + 1</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>LoadArray( inMB, pos, current, stack, outMB )</SourceLine>
   <SourceLine>if pos &lt;= lastIndex and inPtr.Byte( pos ) &lt; 33 then</SourceLine>
   <SourceLine>self.AdvancePastWhiteSpace( inMB, pos )</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if pos &lt;= lastIndex and inPtr.Byte( pos ) &lt; 33 then</SourceLine>
   <SourceLine>self.AdvancePastWhiteSpace( inMB, pos )</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if inPtr.Byte( pos ) = kCloseCurlyBrace then // Empty object</SourceLine>
   <SourceLine>if stack.Ubound &lt;&gt; -1 then</SourceLine>
   <SourceLine>current = stack.Pop</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>current = nil</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>pos = pos + 1</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>LoadObject( inMB, pos, current, stack, outMB )</SourceLine>
   <SourceLine>if pos &lt;= lastIndex and inPtr.Byte( pos ) &lt; 33 then</SourceLine>
   <SourceLine>self.AdvancePastWhiteSpace( inMB, pos )</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if current is nil then</SourceLine>
   <SourceLine>if pos &lt;= lastIndex then</SourceLine>
   <SourceLine>raise new JSONException( "A parsing error occurred", 2, pos )</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>exit do</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>elseif pos &gt; lastIndex then</SourceLine>
   <SourceLine>raise new JSONException( "A parsing error occurred", 2, pos )</SourceLine>
   <SourceLine>exit do</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>if inPtr.Byte( pos ) &lt;  33 then</SourceLine>
   <SourceLine>self.AdvancePastWhiteSpace( inMB, pos )</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>if inPtr.Byte( pos ) = kComma then</SourceLine>
   <SourceLine>pos = pos + 1</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>loop</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>end if // proceed</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>end if // JSONString = ""</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>mIsLoading = false</SourceLine>
   <SourceLine>LoadCS.Leave</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Exception err as RuntimeException</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// Restore original values</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>if originalSetType &lt;&gt; kNeverStarted then</SourceLine>
   <SourceLine>self.Clear</SourceLine>
   <SourceLine>if originalSetType = kHasSetArray then</SourceLine>
   <SourceLine>ArrayValues = originalValue</SourceLine>
   <SourceLine>elseif originalSetType = kHasSetObject then</SourceLine>
   <SourceLine>ObjectValues = originalValue</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>HasSetType = originalSetType</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>mIsLoading = False</SourceLine>
   <SourceLine>LoadCS.Leave</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>raise err</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Sub</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>0</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>JSONString As String</ItemParams>
  <ItemResult></ItemResult>
 </Method>
 <Method>
  <ItemName>Lookup</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>916008959</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function Lookup(name As String, defaultValue As Variant) As Variant</SourceLine>
   <SourceLine>if not EnsureObject() then</SourceLine>
   <SourceLine>return nil</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>dim key as string = NameToKey( name )</SourceLine>
   <SourceLine>return ObjectValues.Lookup( key, defaultValue )</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>0</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>name As String, defaultValue As Variant</ItemParams>
  <ItemResult>Variant</ItemResult>
 </Method>
 <Method>
  <ItemName>Name</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>1322094591</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function Name(index As Integer) As String</SourceLine>
   <SourceLine>if not EnsureObject() then</SourceLine>
   <SourceLine>return ""</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>dim key as string = ObjectValues.Key( index ).StringValue</SourceLine>
   <SourceLine>dim name as string = KeyToName( key )</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>return name</SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>0</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>index As Integer</ItemParams>
  <ItemResult>String</ItemResult>
 </Method>
 <Method>
  <ItemName>Names</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>145336319</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function Names() As String()</SourceLine>
   <SourceLine>if not EnsureObject() then</SourceLine>
   <SourceLine>return nil</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>dim d as Dictionary = ObjectValues</SourceLine>
   <SourceLine>dim keys() as variant = d.Keys</SourceLine>
   <SourceLine>dim r() as string</SourceLine>
   <SourceLine>redim r( keys.Ubound )</SourceLine>
   <SourceLine>for i as integer = 0 to keys.Ubound</SourceLine>
   <SourceLine>dim name as string = keys( i )</SourceLine>
   <SourceLine>name = KeyToName( name )</SourceLine>
   <SourceLine>r( i ) = name</SourceLine>
   <SourceLine>next i</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>return r</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>0</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams></ItemParams>
  <ItemResult>String()</ItemResult>
 </Method>
 <Method>
  <ItemName>Operator_Convert</ItemName>
  <Compatibility></Compatibility>
  <Attributes>hidden</Attributes>
  <Visible>1</Visible>
  <PartID>1717555199</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Attributes( hidden )  Sub Operator_Convert(d As Dictionary)</SourceLine>
   <SourceLine>self.Constructor()</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>dim keys() as variant = d.Keys</SourceLine>
   <SourceLine>dim values() as variant = d.Values</SourceLine>
   <SourceLine>for i as integer = 0 to keys.Ubound</SourceLine>
   <SourceLine>dim name as string = keys( i )</SourceLine>
   <SourceLine>dim value as variant = values( i )</SourceLine>
   <SourceLine>self.Value( name ) = value</SourceLine>
   <SourceLine>next</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Sub</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>0</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>d As Dictionary</ItemParams>
  <ItemResult></ItemResult>
 </Method>
 <Method>
  <ItemName>Operator_Subscript</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>992323583</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function Operator_Subscript(index As Integer) As Variant</SourceLine>
   <SourceLine>return self.Value( index )</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>0</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>index As Integer</ItemParams>
  <ItemResult>Variant</ItemResult>
 </Method>
 <Method>
  <ItemName>Remove</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>232185855</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Sub Remove(index As Integer)</SourceLine>
   <SourceLine>if not EnsureArray() then</SourceLine>
   <SourceLine>return</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>ArrayValues.Remove( index )</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Sub</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>0</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>index As Integer</ItemParams>
  <ItemResult></ItemResult>
 </Method>
 <Method>
  <ItemName>Remove</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>26384383</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Sub Remove(name As String)</SourceLine>
   <SourceLine>if not EnsureObject() then</SourceLine>
   <SourceLine>return</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>dim key as string = NameToKey( name )</SourceLine>
   <SourceLine>ObjectValues.Remove( key )</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Sub</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>0</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>name As String</ItemParams>
  <ItemResult></ItemResult>
 </Method>
 <Method>
  <ItemName>Serialize</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>1024897023</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function Serialize(data As JSONItem_MTC) As String</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// Most JSON will be rather small, so we'll start with a small initial block</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>const kInitialMBSize = 10 * 1024</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>dim outMB as new MemoryBlock( kInitialMBSize )</SourceLine>
   <SourceLine>dim outMBs() as MemoryBlock</SourceLine>
   <SourceLine>outMBs.Append outMB</SourceLine>
   <SourceLine>dim outIndex as integer</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>dim inMB as new MemoryBlock( kInMBSize )</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>data.Serialize( outMBs, outIndex, self, 0, inMB)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// We know exactly how long the last MemoryBlock's data is</SourceLine>
   <SourceLine>// in outIndex</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>dim joiner() as string </SourceLine>
   <SourceLine>redim joiner( outMBs.Ubound)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>for i as integer = 0  to outMBs.Ubound</SourceLine>
   <SourceLine>#if DebugBuild</SourceLine>
   <SourceLine>if i = 1 then</SourceLine>
   <SourceLine>i = i // A place to break</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>#endif</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>outMB = outMBs( i )</SourceLine>
   <SourceLine>outMBs( i ) = nil</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>dim s as string</SourceLine>
   <SourceLine>if i = outMBs.Ubound then</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>s = outMB.StringValue( 0, outIndex )</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// Scan for the final null</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>dim lastBytePos as integer = outMB.Size - 1</SourceLine>
   <SourceLine>dim p as Ptr = outMB</SourceLine>
   <SourceLine>for bytePos as integer = lastBytePos downto 0</SourceLine>
   <SourceLine>if p.Byte( bytePos ) &lt;&gt; 0 then</SourceLine>
   <SourceLine>s = outMB.StringValue( 0, bytePos + 1 )</SourceLine>
   <SourceLine>exit for bytePos</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>next bytePos</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>outMB = nil</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if s = "" then</SourceLine>
   <SourceLine>raise new JSONException( "Couldn't find non-null bytes in a MemoryBlock", 0 )</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>s = s.DefineEncoding( Encodings.UTF8 )</SourceLine>
   <SourceLine>joiner( i ) = s</SourceLine>
   <SourceLine>next i</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>dim r as string = join( joiner, "" )</SourceLine>
   <SourceLine>return r</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>0</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>data As JSONItem_MTC</ItemParams>
  <ItemResult>String</ItemResult>
 </Method>
 <Method>
  <ItemName>Serialize</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>1886904319</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Sub Serialize(outMBs() As MemoryBlock, ByRef outIndex As Integer, settings As JSONItem_MTC, level As Integer, inMB As MemoryBlock)</SourceLine>
   <SourceLine>dim outMB as MemoryBlock = outMBs( outMBs.Ubound )</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>level = level + 1</SourceLine>
   <SourceLine>dim notCompact as boolean = not( settings.Compact ) and settings.IndentSpacing &gt; 0</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>static lotsOfSpaces as string = "        "</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>dim indenter as string</SourceLine>
   <SourceLine>if notCompact then</SourceLine>
   <SourceLine>dim targetLen as integer = level * settings.IndentSpacing</SourceLine>
   <SourceLine>while lotsOfSpaces.LenB &lt; targetLen</SourceLine>
   <SourceLine>lotsOfSpaces = lotsOfSpaces + lotsOfSpaces</SourceLine>
   <SourceLine>wend</SourceLine>
   <SourceLine>indenter = lotsOfSpaces.LeftB( targetLen )</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// Always keep at least a 1024 byte buffer at the end of the outMB</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>dim outSize as integer = outMB.Size</SourceLine>
   <SourceLine>if outIndex &gt; ( outSize - 1024 ) then</SourceLine>
   <SourceLine>outMB = AppendOutMB( outMBs, outIndex )</SourceLine>
   <SourceLine>outSize = outMB.Size</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>dim outPtr as Ptr = outMB</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if IsArray then</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>outPtr.Byte( outIndex ) = kOpenSquareBracket</SourceLine>
   <SourceLine>outIndex = outIndex + 1</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if ArrayValues.Ubound &lt;&gt; -1 then</SourceLine>
   <SourceLine>if notCompact then</SourceLine>
   <SourceLine>#if TargetWin32</SourceLine>
   <SourceLine>outPtr.Byte( outIndex ) = 13</SourceLine>
   <SourceLine>outIndex = outIndex + 1</SourceLine>
   <SourceLine>#endif</SourceLine>
   <SourceLine>outPtr.Byte( outIndex ) = 10</SourceLine>
   <SourceLine>outIndex = outIndex + 1</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>for i as integer = 0 to ArrayValues.Ubound</SourceLine>
   <SourceLine>if outIndex &gt; ( outSize - 1024 ) then</SourceLine>
   <SourceLine>outMB = AppendOutMB( outMBs, outIndex )</SourceLine>
   <SourceLine>outSize = outMB.Size</SourceLine>
   <SourceLine>outPtr = outMB</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if notCompact then</SourceLine>
   <SourceLine>outMB.StringValue( outIndex, indenter.LenB ) = indenter</SourceLine>
   <SourceLine>outIndex = outIndex + indenter.LenB</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>dim value as variant = ArrayValues( i )</SourceLine>
   <SourceLine>EncodeValue( value, settings, level, outMBs, outIndex, inMB )</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>outMB = outMBs( outMBs.Ubound )</SourceLine>
   <SourceLine>outSize = outMB.Size</SourceLine>
   <SourceLine>if outIndex &gt; ( outSize - 1024 ) then</SourceLine>
   <SourceLine>outMB = AppendOutMB( outMBs, outIndex )</SourceLine>
   <SourceLine>outSize = outMB.Size</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>outPtr = outMB</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if i &lt; ArrayValues.Ubound then</SourceLine>
   <SourceLine>outPtr.Byte( outIndex ) = kComma</SourceLine>
   <SourceLine>outIndex = outIndex + 1</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>if notCompact then</SourceLine>
   <SourceLine>#if TargetWin32</SourceLine>
   <SourceLine>outPtr.Byte( outIndex ) = 13</SourceLine>
   <SourceLine>outIndex = outIndex + 1</SourceLine>
   <SourceLine>#endif</SourceLine>
   <SourceLine>outPtr.Byte( outIndex ) = 10</SourceLine>
   <SourceLine>outIndex = outIndex + 1</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>next i</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if outIndex &gt; ( outSize - 1024 ) then</SourceLine>
   <SourceLine>outMB = AppendOutMB( outMBs, outIndex )</SourceLine>
   <SourceLine>outSize = outMB.Size</SourceLine>
   <SourceLine>outPtr = outMB</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if notCompact then</SourceLine>
   <SourceLine>if outIndex &gt; ( outSize - indenter.LenB ) then</SourceLine>
   <SourceLine>outMB = AppendOutMB( outMBs, outIndex )</SourceLine>
   <SourceLine>outSize = outMB.Size</SourceLine>
   <SourceLine>outPtr = outMB</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>outMB.StringValue( outIndex, indenter.LenB - settings.IndentSpacing ) = indenter.LeftB( indenter.LenB - indentSpacing )</SourceLine>
   <SourceLine>outIndex = outIndex + ( indenter.LenB - settings.IndentSpacing )</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if outIndex &gt; ( outSize - 1024 ) then</SourceLine>
   <SourceLine>outMB = AppendOutMB( outMBs, outIndex )</SourceLine>
   <SourceLine>outSize = outMB.Size</SourceLine>
   <SourceLine>outPtr = outMB</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>outPtr.Byte( outIndex ) = kCloseSquareBracket</SourceLine>
   <SourceLine>outIndex = outIndex + 1</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>dim d as Dictionary = ObjectValues</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>outPtr.Byte( outIndex ) = kOpenCurlyBrace</SourceLine>
   <SourceLine>outIndex = outIndex + 1</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if d.Count &lt;&gt; 0 then</SourceLine>
   <SourceLine>if notCompact then</SourceLine>
   <SourceLine>#if TargetWin32</SourceLine>
   <SourceLine>outPtr.Byte( outIndex ) = 13</SourceLine>
   <SourceLine>outIndex = outIndex + 1</SourceLine>
   <SourceLine>#endif</SourceLine>
   <SourceLine>outPtr.Byte( outIndex ) = 10</SourceLine>
   <SourceLine>outIndex = outIndex + 1</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>dim keys() as variant = d.Keys</SourceLine>
   <SourceLine>for i as integer = 0 to keys.Ubound</SourceLine>
   <SourceLine>if outIndex &gt; ( outSize - 1024 ) then</SourceLine>
   <SourceLine>outMB = AppendOutMB( outMBs, outIndex )</SourceLine>
   <SourceLine>outSize = outMB.Size</SourceLine>
   <SourceLine>outPtr = outMB</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if notCompact then</SourceLine>
   <SourceLine>outMB.StringValue( outIndex, indenter.LenB ) = indenter</SourceLine>
   <SourceLine>outIndex = outIndex + indenter.LenB</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>dim key as variant = keys( i )</SourceLine>
   <SourceLine>dim name as string = KeyToName( key )</SourceLine>
   <SourceLine>EncodeString( name, settings, outMBs, outIndex, inMB )</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>outMB = outMBs( outMBs.Ubound )</SourceLine>
   <SourceLine>outSize  = outMB.Size</SourceLine>
   <SourceLine>if outIndex &gt; ( outSize - 1 ) then</SourceLine>
   <SourceLine>outMB = AppendOutMB( outMBs, outIndex )</SourceLine>
   <SourceLine>outSize = outMB.Size</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>outPtr = outMB</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>outPtr.Byte( outIndex ) = kColon</SourceLine>
   <SourceLine>outIndex = outIndex + 1</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>dim value as variant = d.Value( key )</SourceLine>
   <SourceLine>EncodeValue( value, settings, level, outMBs, outIndex, inMB )</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>outMB = outMBs( outMBs.Ubound )</SourceLine>
   <SourceLine>outSize  = outMB.Size</SourceLine>
   <SourceLine>if outIndex &gt; ( outSize - 1024 ) then</SourceLine>
   <SourceLine>outMB = AppendOutMB( outMBs, outIndex )</SourceLine>
   <SourceLine>outSize = outMB.Size</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>outPtr = outMB</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if i &lt; keys.Ubound then</SourceLine>
   <SourceLine>outPtr.Byte( outIndex ) = kComma</SourceLine>
   <SourceLine>outIndex = outIndex + 1</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>if notCompact then</SourceLine>
   <SourceLine>#if TargetWin32</SourceLine>
   <SourceLine>outPtr.Byte( outIndex ) = 13</SourceLine>
   <SourceLine>outIndex = outIndex + 1</SourceLine>
   <SourceLine>#endif</SourceLine>
   <SourceLine>outPtr.Byte( outIndex ) = 10</SourceLine>
   <SourceLine>outIndex = outIndex + 1</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>next</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if notCompact then</SourceLine>
   <SourceLine>if outIndex &gt; ( outSize - indenter.LenB ) then</SourceLine>
   <SourceLine>outMB = AppendOutMB( outMBs, outIndex )</SourceLine>
   <SourceLine>outSize = outMB.Size</SourceLine>
   <SourceLine>outPtr = outMB</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>outMB.StringValue( outIndex, indenter.LenB - settings.IndentSpacing ) = indenter.LeftB( indenter.LenB - indentSpacing )</SourceLine>
   <SourceLine>outIndex = outIndex + ( indenter.LenB - settings.IndentSpacing )</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if outIndex &gt; ( outSize - 1024 ) then</SourceLine>
   <SourceLine>outMB = AppendOutMB( outMBs, outIndex )</SourceLine>
   <SourceLine>outSize = outMB.Size</SourceLine>
   <SourceLine>outPtr = outMB</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>outPtr.Byte( outIndex ) = kCloseCurlyBrace</SourceLine>
   <SourceLine>outIndex = outIndex + 1</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Sub</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>1</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>outMBs() As MemoryBlock, ByRef outIndex As Integer, settings As JSONItem_MTC, level As Integer, inMB As MemoryBlock</ItemParams>
  <ItemResult></ItemResult>
 </Method>
 <Method>
  <ItemName>Value</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>2141319167</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function Value(index As Integer) As Variant</SourceLine>
   <SourceLine>if not EnsureArray() then</SourceLine>
   <SourceLine>return nil</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>return ArrayValues( index )</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>0</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>index As Integer</ItemParams>
  <ItemResult>Variant</ItemResult>
 </Method>
 <Method>
  <ItemName>Value</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>1970421759</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Sub Value(index As Integer, Assigns value As Variant)</SourceLine>
   <SourceLine>if not EnsureArray() then</SourceLine>
   <SourceLine>return</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Validate( value )</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>HasSetType = kHasSetArray</SourceLine>
   <SourceLine>if ArrayValues.Ubound &lt; index then</SourceLine>
   <SourceLine>ArrayValues.Append value</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>ArrayValues( index ) = value</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Sub</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>0</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>index As Integer, Assigns value As Variant</ItemParams>
  <ItemResult></ItemResult>
 </Method>
 <Method>
  <ItemName>Value</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>396521471</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function Value(name As String) As Variant</SourceLine>
   <SourceLine>if not EnsureObject() then</SourceLine>
   <SourceLine>return nil</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>dim key as string = NameToKey( name )</SourceLine>
   <SourceLine>return ObjectValues.Value( key )</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>0</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>name As String</ItemParams>
  <ItemResult>Variant</ItemResult>
 </Method>
 <Method>
  <ItemName>Value</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>41064447</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Sub Value(name As String, Assigns value As Variant)</SourceLine>
   <SourceLine>if not EnsureObject then</SourceLine>
   <SourceLine>return</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Validate( value )</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>HasSetType = kHasSetObject</SourceLine>
   <SourceLine>dim key as string = NameToKey( name )</SourceLine>
   <SourceLine>ObjectValues.Value( key ) = value</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Sub</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>0</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>name As String, Assigns value As Variant</ItemParams>
  <ItemResult></ItemResult>
 </Method>
 <Method>
  <ItemName>NameToKey</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>1782718463</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function NameToKey(name As String) As String</SourceLine>
   <SourceLine>name = name.ConvertEncoding( Encodings.UTF8 )</SourceLine>
   <SourceLine>dim key as string = name + "-" + EncodeHex( name )</SourceLine>
   <SourceLine>return key</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>name As String</ItemParams>
  <ItemResult>String</ItemResult>
 </Method>
 <Method>
  <ItemName>KeyToName</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>826953727</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function KeyToName(key As String) As String</SourceLine>
   <SourceLine>dim hex as string = key.NthField( "-", key.CountFields( "-" ) )</SourceLine>
   <SourceLine>dim name as string = key.LeftB( key.LenB - hex.LenB - 1 )</SourceLine>
   <SourceLine>return name</SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>key As String</ItemParams>
  <ItemResult>String</ItemResult>
 </Method>
 <Method>
  <ItemName>Validate</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>1620037631</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Sub Validate(ByRef value As Variant)</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// If value holds a Dictionary or Array,</SourceLine>
   <SourceLine>// this will do the conversion and allow the new</SourceLine>
   <SourceLine>// object to raise an exception if needed</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>dim isGood as boolean = true // Assume it is</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if value.IsArray then</SourceLine>
   <SourceLine>dim jsonArr as JSONItem_MTC</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>select case value.ArrayElementType</SourceLine>
   <SourceLine>case Variant.TypeBoolean</SourceLine>
   <SourceLine>dim arr() as boolean = value</SourceLine>
   <SourceLine>jsonArr = arr</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>case Variant.TypeDouble</SourceLine>
   <SourceLine>dim arr() as double = value</SourceLine>
   <SourceLine>jsonArr = arr</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>case Variant.TypeInt32</SourceLine>
   <SourceLine>dim arr() as Int32 = value</SourceLine>
   <SourceLine>jsonArr = arr</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>case Variant.TypeInt64</SourceLine>
   <SourceLine>dim arr() as Int64 = value</SourceLine>
   <SourceLine>jsonArr = arr</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>case Variant.TypeSingle</SourceLine>
   <SourceLine>dim arr() as single = value</SourceLine>
   <SourceLine>jsonArr = arr</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>case Variant.TypeString</SourceLine>
   <SourceLine>dim arr() as string = value</SourceLine>
   <SourceLine>jsonArr = arr</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>case Variant.TypeText</SourceLine>
   <SourceLine>dim arr() as text = value</SourceLine>
   <SourceLine>jsonArr = arr</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>case Variant.TypeObject</SourceLine>
   <SourceLine>dim arr() as object = value</SourceLine>
   <SourceLine>jsonArr = arr</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>case else</SourceLine>
   <SourceLine>isGood = false</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>end select</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if isGood then</SourceLine>
   <SourceLine>value = jsonArr</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>select case value.Type</SourceLine>
   <SourceLine>case Variant.TypeNil, Variant.TypeBoolean</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>case Variant.TypeString, Variant.TypeCString, Variant.TypePString, Variant.TypeText</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>case Variant.TypeDouble, Variant.TypeSingle, Variant.TypeCurrency</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>case Variant.TypeInt32, Variant.TypeInt64, Variant.TypeInteger</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>case Variant.TypeObject</SourceLine>
   <SourceLine>select case value</SourceLine>
   <SourceLine>case IsA JSONItem_MTC</SourceLine>
   <SourceLine>case IsA Dictionary</SourceLine>
   <SourceLine>dim dictJSON as JSONItem_MTC = Dictionary( value )</SourceLine>
   <SourceLine>value = dictJSON</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>raise new JSONException( "Unrecognized Object", 11 )</SourceLine>
   <SourceLine>end select</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>isGood = false</SourceLine>
   <SourceLine>end</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if not isGood then</SourceLine>
   <SourceLine>raise new JSONException( "Illegal Value", 10 )</SourceLine>
   <SourceLine>end</SourceLine>
   <SourceLine>End Sub</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>ByRef value As Variant</ItemParams>
  <ItemResult></ItemResult>
 </Method>
 <Method>
  <ItemName>JSONStringToUTF8</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>1223368703</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function JSONStringToUTF8(s As String) As String</SourceLine>
   <SourceLine>// Ensures that the given string is converted to UTF8.</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// A string obtained from an unknown source might be nil or might </SourceLine>
   <SourceLine>// be marked as the wrong encoding, so we won't trust it</SourceLine>
   <SourceLine>// and will check ourselves.</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// Since the string must start with characters in the ASCII range</SourceLine>
   <SourceLine>// (whitespace, {, or [), we only need the first four bytes.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>static null as string = ChrB( 0 )</SourceLine>
   <SourceLine>static doubleNull as string  = null + null</SourceLine>
   <SourceLine>static tripleNull as string = null + null + null</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>dim firstFour as string = s.LeftB( 4 )</SourceLine>
   <SourceLine>if firstFour.LenB &lt; 2 or firstFour.LenB = 3 then</SourceLine>
   <SourceLine>return s.DefineEncoding( Encodings.UTF8 )</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// </SourceLine>
   <SourceLine>// Check for BOM</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>if true then // Scope</SourceLine>
   <SourceLine>static bomArr() as string = Array( _</SourceLine>
   <SourceLine>ChrB( &amp;hFF ) + ChrB( &amp;hFE ) + doubleNull, _</SourceLine>
   <SourceLine>doubleNull + ChrB( &amp;hFE ) + ChrB( &amp;hFF ), _</SourceLine>
   <SourceLine>ChrB( &amp;hEF ) + ChrB( &amp;hBB ) + ChrB( &amp;hBF ), _</SourceLine>
   <SourceLine>ChrB( &amp;hFF ) + ChrB( &amp;hFE ), _</SourceLine>
   <SourceLine>ChrB( &amp;hFE ) + ChrB( &amp;hFF ) _</SourceLine>
   <SourceLine>)</SourceLine>
   <SourceLine>&#32;</SourceLine>
   <SourceLine>for i as integer = 0 to bomArr.Ubound</SourceLine>
   <SourceLine>dim bom as string = bomArr( i )</SourceLine>
   <SourceLine>dim bomLen as integer = bom.LenB</SourceLine>
   <SourceLine>if firstFour.LeftB( bomLen ) = bom then</SourceLine>
   <SourceLine>s = s.MidB( bomLen + 1 )</SourceLine>
   <SourceLine>firstFour = s.LeftB( 4 )</SourceLine>
   <SourceLine>exit</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>next i</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Check for UTF8</SourceLine>
   <SourceLine>if firstFour.InStrB( null ) = 0 then</SourceLine>
   <SourceLine>return s.DefineEncoding( Encodings.UTF8 )</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// UTF32?</SourceLine>
   <SourceLine>if firstFour.LenB = 4 then</SourceLine>
   <SourceLine>if firstFour.LeftB( 3 ) = tripleNull then</SourceLine>
   <SourceLine>s = s.DefineEncoding( Encodings.UTF32BE )</SourceLine>
   <SourceLine>return s.ConvertEncoding( Encodings.UTF8 )</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>if firstFour.RightB( 3 ) = tripleNull then</SourceLine>
   <SourceLine>s = s.DefineEncoding( Encodings.UTF32LE )</SourceLine>
   <SourceLine>return s.ConvertEncoding( Encodings.UTF8 )</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// UTF16?</SourceLine>
   <SourceLine>if firstFour.LeftB( 1 ) = null then</SourceLine>
   <SourceLine>s = s.DefineEncoding( Encodings.UTF16BE )</SourceLine>
   <SourceLine>return s.ConvertEncoding( Encodings.UTF8 )</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>if firstFour.RightB( 1 ) = null then</SourceLine>
   <SourceLine>s = s.DefineEncoding( Encodings.UTF16LE )</SourceLine>
   <SourceLine>return s.ConvertEncoding( Encodings.UTF8 )</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// We don't know what the heck it is</SourceLine>
   <SourceLine>return s</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>s As String</ItemParams>
  <ItemResult>String</ItemResult>
 </Method>
 <Method>
  <ItemName>LoadObject</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>119379967</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Sub LoadObject(inMB As MemoryBlock, ByRef pos As Integer, ByRef current As JSONItem_MTC, stack() As JSONItem_MTC, outMB As MemoryBlock)</SourceLine>
   <SourceLine>dim inPtr As Ptr = inMB</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>dim name as string</SourceLine>
   <SourceLine>dim key as string</SourceLine>
   <SourceLine>dim value as variant</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>do</SourceLine>
   <SourceLine>if inPtr.Byte( pos ) &lt; 33 then</SourceLine>
   <SourceLine>self.AdvancePastWhiteSpace( inMB, pos )</SourceLine>
   <SourceLine>end if </SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if inPtr.Byte( pos ) = kCloseCurlyBrace then</SourceLine>
   <SourceLine>pos = pos + 1</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if stack.Ubound &lt;&gt; -1 then</SourceLine>
   <SourceLine>current = stack.Pop</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>current = nil</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>exit do</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>name = DecodeString( inMB, pos, current, outMB )</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if inPtr.Byte( pos ) &lt; 33 then</SourceLine>
   <SourceLine>self.AdvancePastWhiteSpace( inMB, pos )</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if inPtr.Byte( pos ) &lt;&gt; kColon then</SourceLine>
   <SourceLine>// Something is wrong</SourceLine>
   <SourceLine>raise new JSONException( "Missing :", 5, pos + 1 )</SourceLine>
   <SourceLine>exit do</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>pos = pos + 1</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if inPtr.Byte( pos ) &lt; 33 then</SourceLine>
   <SourceLine>self.AdvancePastWhiteSpace( inMB, pos )</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>value = DecodeValue( inMB, pos, current, outMB )</SourceLine>
   <SourceLine>key = NameToKey( name )</SourceLine>
   <SourceLine>current.ObjectValues.Value( key ) = value</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if value IsA JSONItem_MTC then</SourceLine>
   <SourceLine>stack.Append current</SourceLine>
   <SourceLine>current = value</SourceLine>
   <SourceLine>exit do</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if inPtr.Byte( pos ) &lt; 33 then</SourceLine>
   <SourceLine>self.AdvancePastWhiteSpace( inMB, pos )</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if inPtr.Byte( pos ) = kComma then</SourceLine>
   <SourceLine>pos = pos + 1</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>loop</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Sub</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>inMB As MemoryBlock, ByRef pos As Integer, ByRef current As JSONItem_MTC, stack() As JSONItem_MTC, outMB As MemoryBlock</ItemParams>
  <ItemResult></ItemResult>
 </Method>
 <Method>
  <ItemName>LoadArray</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>740392959</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Sub LoadArray(inMB As MemoryBlock, ByRef pos As Integer, ByRef current As JSONItem_MTC, stack() As JSONItem_MTC, outMB As MemoryBlock)</SourceLine>
   <SourceLine>dim inPtr As Ptr = inMB</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>dim commaFound as boolean</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>dim value as variant</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>do</SourceLine>
   <SourceLine>if inPtr.Byte( pos ) &lt; 33 then</SourceLine>
   <SourceLine>self.AdvancePastWhiteSpace( inMB, pos )</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if inPtr.Byte( pos ) = kCloseSquareBracket then</SourceLine>
   <SourceLine>if commaFound then</SourceLine>
   <SourceLine>raise new JSONException( "Illegal Value", 10, pos )</SourceLine>
   <SourceLine>exit do</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>pos = pos + 1</SourceLine>
   <SourceLine>if stack.Ubound &lt;&gt; -1 then</SourceLine>
   <SourceLine>current = stack.Pop</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>current = nil</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>exit do</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>value = DecodeValue( inMB, pos, current, outMB )</SourceLine>
   <SourceLine>current.ArrayValues.Append value</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if value IsA JSONItem_MTC then</SourceLine>
   <SourceLine>stack.Append current</SourceLine>
   <SourceLine>current = value</SourceLine>
   <SourceLine>exit do</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if inPtr.Byte( pos ) &lt; 33 then</SourceLine>
   <SourceLine>self.AdvancePastWhiteSpace( inMB, pos )</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>commaFound = false</SourceLine>
   <SourceLine>if inPtr.Byte( pos ) = kComma then</SourceLine>
   <SourceLine>pos = pos + 1</SourceLine>
   <SourceLine>commaFound = true</SourceLine>
   <SourceLine>elseif inPtr.Byte( pos ) &lt;&gt; kCloseSquareBracket then</SourceLine>
   <SourceLine>raise new JSONException( "A parsing error occurred", 2, pos + 1 )</SourceLine>
   <SourceLine>exit do</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>loop</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Sub</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>inMB As MemoryBlock, ByRef pos As Integer, ByRef current As JSONItem_MTC, stack() As JSONItem_MTC, outMB As MemoryBlock</ItemParams>
  <ItemResult></ItemResult>
 </Method>
 <Method>
  <ItemName>ParseNumber</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>1864783871</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function ParseNumber(mb As MemoryBlock, startPos As Integer, endPos As Integer, ByRef result As Variant) As Boolean</SourceLine>
   <SourceLine>if endPos &gt;= mb.Size then</SourceLine>
   <SourceLine>endPos = mb.Size - 1</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if endPos &lt;= startPos then</SourceLine>
   <SourceLine>return false</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>dim p as Ptr = mb</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>dim dotFound as boolean</SourceLine>
   <SourceLine>dim inExponent as boolean</SourceLine>
   <SourceLine>dim r as boolean = true</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>dim pos as integer = startPos</SourceLine>
   <SourceLine>dim thisByte as integer = p.Byte( pos )</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>dim isNegative as boolean</SourceLine>
   <SourceLine>if thisByte = kHyphen then</SourceLine>
   <SourceLine>isNegative = true</SourceLine>
   <SourceLine>pos = pos + 1</SourceLine>
   <SourceLine>elseif thisByte = kPlus then</SourceLine>
   <SourceLine>pos = pos + 1</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>dim total as Int64</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>do</SourceLine>
   <SourceLine>thisByte = p.Byte( pos )</SourceLine>
   <SourceLine>select case thisByte</SourceLine>
   <SourceLine>case kDot</SourceLine>
   <SourceLine>if dotFound or inExponent then</SourceLine>
   <SourceLine>r = false</SourceLine>
   <SourceLine>exit do</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>dotFound = true</SourceLine>
   <SourceLine>pos = pos + 1</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>case 48 to 57</SourceLine>
   <SourceLine>if not dotFound and not inExponent then</SourceLine>
   <SourceLine>total = ( total * 10 ) + ( thisByte - 48 )</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>pos = pos + 1</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>case 101, 69 // e, E</SourceLine>
   <SourceLine>if inExponent then</SourceLine>
   <SourceLine>r = false</SourceLine>
   <SourceLine>exit do</SourceLine>
   <SourceLine>elseif Strict and dotFound and p.Byte( pos - 1 ) = kDot then</SourceLine>
   <SourceLine>r = false</SourceLine>
   <SourceLine>exit do</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>inExponent = true</SourceLine>
   <SourceLine>pos = pos + 1</SourceLine>
   <SourceLine>if pos &gt; endPos then</SourceLine>
   <SourceLine>r = false</SourceLine>
   <SourceLine>exit do</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>thisByte = p.Byte( pos )</SourceLine>
   <SourceLine>if thisByte = 45 or thisByte = 43 then</SourceLine>
   <SourceLine>pos = pos + 1</SourceLine>
   <SourceLine>if pos &gt; endPos then</SourceLine>
   <SourceLine>r = false</SourceLine>
   <SourceLine>exit do</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>end  if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>r = false</SourceLine>
   <SourceLine>exit do</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>end select</SourceLine>
   <SourceLine>loop until pos &gt; endPos</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if r and Strict and dotFound and ( p.Byte( endPos ) &lt; 48 or p.Byte( endPos ) &gt; 57 ) then</SourceLine>
   <SourceLine>r = false</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if r then</SourceLine>
   <SourceLine>if not dotFound and not inExponent then // Integer</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if isNegative then</SourceLine>
   <SourceLine>total = 0 - total</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>result = total</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>dim s as string = mb.StringValue( startPos, endPos - startPos + 1 )</SourceLine>
   <SourceLine>result = Val( s )</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>return r</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>mb As MemoryBlock, startPos As Integer, endPos As Integer, ByRef result As Variant</ItemParams>
  <ItemResult>Boolean</ItemResult>
 </Method>
 <Method>
  <ItemName>EncodeCodepoint</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>172034047</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Sub EncodeCodepoint(value As Integer, outPtr As Ptr, pos As Integer)</SourceLine>
   <SourceLine>// WARNING: Assumption is that the destination has enough room</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>static hexByteArr() as integer = Array( 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 65, 66, 67, 68, 69, 70 ) // 0-9, A- F</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>outPtr.Byte( pos + 3 ) = hexByteArr( value and &amp;h0F )</SourceLine>
   <SourceLine>outPtr.Byte( pos + 2 ) = hexByteArr( Bitwise.ShiftRight( value, 4, 32 ) and &amp;h0F )</SourceLine>
   <SourceLine>outPtr.Byte( pos + 1 ) = hexByteArr( Bitwise.ShiftRight( value, 8, 32 ) and &amp;h0F )</SourceLine>
   <SourceLine>outPtr.Byte( pos ) = hexByteArr( Bitwise.ShiftRight( value, 12, 32 ) and &amp;h0F )</SourceLine>
   <SourceLine>End Sub</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>value As Integer, outPtr As Ptr, pos As Integer</ItemParams>
  <ItemResult></ItemResult>
 </Method>
 <Method>
  <ItemName>IsLoading</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>1337812991</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function IsLoading() As Boolean</SourceLine>
   <SourceLine>return mIsLoading</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>0</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams></ItemParams>
  <ItemResult>Boolean</ItemResult>
 </Method>
 <Method>
  <ItemName>Operator_Subscript</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>1431545855</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Sub Operator_Subscript(index As Integer, Assigns value As Variant)</SourceLine>
   <SourceLine>self.Value( index ) = value</SourceLine>
   <SourceLine>End Sub</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>0</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>index As Integer, Assigns value As Variant</ItemParams>
  <ItemResult></ItemResult>
 </Method>
 <Method>
  <ItemName>AppendOutMB</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>711995391</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function AppendOutMB(outMBs() As MemoryBlock, ByRef outIndex As Integer) As MemoryBlock</SourceLine>
   <SourceLine>dim outMB as MemoryBlock</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>outMB = new MemoryBlock( kOutMBSize )</SourceLine>
   <SourceLine>outMBs.Append outMB</SourceLine>
   <SourceLine>outIndex = 0</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>return outMB</SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>outMBs() As MemoryBlock, ByRef outIndex As Integer</ItemParams>
  <ItemResult>MemoryBlock</ItemResult>
 </Method>
 <Method>
  <ItemName>ParseJSON</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>484835327</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Shared Function ParseJSON(s As String) As Variant</SourceLine>
   <SourceLine>dim j as new JSONItem_MTC( s )</SourceLine>
   <SourceLine>return j.ToNativeValue</SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>0</ItemFlags>
  <IsShared>1</IsShared>
  <ItemParams>s As String</ItemParams>
  <ItemResult>Variant</ItemResult>
 </Method>
 <Method>
  <ItemName>Operator_Convert</ItemName>
  <Compatibility></Compatibility>
  <Attributes>hidden</Attributes>
  <Visible>1</Visible>
  <PartID>1871661055</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Attributes( hidden )  Sub Operator_Convert(arr() As String)</SourceLine>
   <SourceLine>self.Constructor()</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>for each v as string in arr</SourceLine>
   <SourceLine>self.Append v</SourceLine>
   <SourceLine>next</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Sub</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>0</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>arr() As String</ItemParams>
  <ItemResult></ItemResult>
 </Method>
 <Method>
  <ItemName>Operator_Convert</ItemName>
  <Compatibility></Compatibility>
  <Attributes>hidden</Attributes>
  <Visible>1</Visible>
  <PartID>1799974911</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Attributes( hidden )  Sub Operator_Convert(arr() As Int32)</SourceLine>
   <SourceLine>self.Constructor()</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>for each v as Int32 in arr</SourceLine>
   <SourceLine>self.Append v</SourceLine>
   <SourceLine>next</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Sub</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>0</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>arr() As Int32</ItemParams>
  <ItemResult></ItemResult>
 </Method>
 <Method>
  <ItemName>Operator_Convert</ItemName>
  <Compatibility></Compatibility>
  <Attributes>hidden</Attributes>
  <Visible>1</Visible>
  <PartID>1891786751</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Attributes( hidden )  Sub Operator_Convert(arr() As Int64)</SourceLine>
   <SourceLine>self.Constructor()</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>for each v as Int64 in arr</SourceLine>
   <SourceLine>self.Append v</SourceLine>
   <SourceLine>next</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Sub</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>0</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>arr() As Int64</ItemParams>
  <ItemResult></ItemResult>
 </Method>
 <Method>
  <ItemName>Operator_Convert</ItemName>
  <Compatibility></Compatibility>
  <Attributes>hidden</Attributes>
  <Visible>1</Visible>
  <PartID>775534591</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Attributes( hidden )  Sub Operator_Convert(arr() As Boolean)</SourceLine>
   <SourceLine>self.Constructor()</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>for each v as boolean in arr</SourceLine>
   <SourceLine>self.Append v</SourceLine>
   <SourceLine>next</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Sub</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>0</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>arr() As Boolean</ItemParams>
  <ItemResult></ItemResult>
 </Method>
 <Method>
  <ItemName>Operator_Convert</ItemName>
  <Compatibility></Compatibility>
  <Attributes>hidden</Attributes>
  <Visible>1</Visible>
  <PartID>2086141951</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Attributes( hidden )  Sub Operator_Convert(arr() As Double)</SourceLine>
   <SourceLine>self.Constructor()</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>for each v as double in arr</SourceLine>
   <SourceLine>self.Append v</SourceLine>
   <SourceLine>next</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Sub</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>0</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>arr() As Double</ItemParams>
  <ItemResult></ItemResult>
 </Method>
 <Method>
  <ItemName>Operator_Convert</ItemName>
  <Compatibility></Compatibility>
  <Attributes>hidden</Attributes>
  <Visible>1</Visible>
  <PartID>1175330815</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Attributes( hidden )  Sub Operator_Convert(arr() As Single)</SourceLine>
   <SourceLine>self.Constructor()</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>for each v as single in arr</SourceLine>
   <SourceLine>self.Append v</SourceLine>
   <SourceLine>next</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Sub</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>0</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>arr() As Single</ItemParams>
  <ItemResult></ItemResult>
 </Method>
 <Method>
  <ItemName>Operator_Convert</ItemName>
  <Compatibility></Compatibility>
  <Attributes>hidden</Attributes>
  <Visible>1</Visible>
  <PartID>509423615</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Attributes( hidden )  Sub Operator_Convert(arr() As Currency)</SourceLine>
   <SourceLine>self.Constructor()</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>for each v as currency in arr</SourceLine>
   <SourceLine>self.Append v</SourceLine>
   <SourceLine>next</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Sub</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>0</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>arr() As Currency</ItemParams>
  <ItemResult></ItemResult>
 </Method>
 <Method>
  <ItemName>Operator_Convert</ItemName>
  <Compatibility></Compatibility>
  <Attributes>hidden</Attributes>
  <Visible>1</Visible>
  <PartID>1201774591</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Attributes( hidden )  Sub Operator_Convert(arr() As Text)</SourceLine>
   <SourceLine>self.Constructor()</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>for each v as text in arr</SourceLine>
   <SourceLine>self.Append v</SourceLine>
   <SourceLine>next</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Sub</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>0</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>arr() As Text</ItemParams>
  <ItemResult></ItemResult>
 </Method>
 <Method>
  <ItemName>Operator_Convert</ItemName>
  <Compatibility></Compatibility>
  <Attributes>hidden</Attributes>
  <Visible>1</Visible>
  <PartID>257023999</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Attributes( hidden )  Sub Operator_Convert(arr() As Variant)</SourceLine>
   <SourceLine>self.Constructor()</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>for each v as variant in arr</SourceLine>
   <SourceLine>self.Append v</SourceLine>
   <SourceLine>next</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Sub</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>0</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>arr() As Variant</ItemParams>
  <ItemResult></ItemResult>
 </Method>
 <Method>
  <ItemName>Operator_Convert</ItemName>
  <Compatibility></Compatibility>
  <Attributes>hidden</Attributes>
  <Visible>1</Visible>
  <PartID>742680575</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Attributes( hidden )  Sub Operator_Convert(arr() As Object)</SourceLine>
   <SourceLine>self.Constructor()</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>for each v as object in arr</SourceLine>
   <SourceLine>self.Append v</SourceLine>
   <SourceLine>next</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Sub</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>0</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>arr() As Object</ItemParams>
  <ItemResult></ItemResult>
 </Method>
 <Method>
  <ItemName>Operator_Convert</ItemName>
  <Compatibility></Compatibility>
  <Attributes>hidden</Attributes>
  <Visible>1</Visible>
  <PartID>1756710911</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Attributes( hidden )  Function Operator_Convert() As Dictionary</SourceLine>
   <SourceLine>if IsArray then</SourceLine>
   <SourceLine>raise new TypeMismatchException</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>dim d as Dictionary = Dictionary( ToNativeValue )</SourceLine>
   <SourceLine>if d is nil then</SourceLine>
   <SourceLine>d = new Dictionary</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>return d</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>0</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams></ItemParams>
  <ItemResult>Dictionary</ItemResult>
 </Method>
 <Method>
  <ItemName>Operator_Convert</ItemName>
  <Compatibility></Compatibility>
  <Attributes>hidden</Attributes>
  <Visible>1</Visible>
  <PartID>182622207</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Attributes( hidden )  Function Operator_Convert() As Variant()</SourceLine>
   <SourceLine>if IsObject then</SourceLine>
   <SourceLine>raise new TypeMismatchException</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>dim arr() as variant</SourceLine>
   <SourceLine>dim native as variant = ToNativeValue</SourceLine>
   <SourceLine>if not native.IsNull then</SourceLine>
   <SourceLine>arr = native</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>return arr</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>0</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams></ItemParams>
  <ItemResult>Variant()</ItemResult>
 </Method>
 <Method>
  <ItemName>Operator_Compare</ItemName>
  <Compatibility></Compatibility>
  <Attributes>hidden</Attributes>
  <Visible>1</Visible>
  <PartID>336379903</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Attributes( hidden )  Function Operator_Compare(compare As JSONItem_MTC) As Integer</SourceLine>
   <SourceLine>if compare is nil then</SourceLine>
   <SourceLine>return 1</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if Count &lt;&gt; compare.Count then</SourceLine>
   <SourceLine>return Count - compare.Count</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>elseif Count = 0 then</SourceLine>
   <SourceLine>return 0</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if IsObject &lt;&gt; compare.IsObject then</SourceLine>
   <SourceLine>return -1 // Meaningless, really</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// Same count, same type, let's dive in</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>dim result as integer</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if IsArray then</SourceLine>
   <SourceLine>dim arr1() as variant = self.ArrayValues</SourceLine>
   <SourceLine>dim arr2() as variant = compare.ArrayValues</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>for i as integer = 0 to arr1.Ubound</SourceLine>
   <SourceLine>dim v1 as variant = arr1( i )</SourceLine>
   <SourceLine>dim v2 as variant = arr2( i )</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>result = CompareValues( v1, v2 )</SourceLine>
   <SourceLine>if result &lt;&gt; 0 then</SourceLine>
   <SourceLine>exit</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>next</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>else // IsObject</SourceLine>
   <SourceLine>dim d1 as Dictionary = self.ObjectValues</SourceLine>
   <SourceLine>dim d2 as Dictionary = compare.ObjectValues</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// Since we know the count is the same, every key and value must match</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>dim keys() as variant = d1.Keys</SourceLine>
   <SourceLine>dim values() as variant = d1.Values</SourceLine>
   <SourceLine>for i as integer = 0 to keys.Ubound</SourceLine>
   <SourceLine>dim key as variant = keys( i )</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if not d2.HasKey( key ) then</SourceLine>
   <SourceLine>result = 1 // Meaningless</SourceLine>
   <SourceLine>exit</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>dim v1 as variant = values( i )</SourceLine>
   <SourceLine>dim v2 as variant = d2.Value( key )</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>result = CompareValues( v1, v2 )</SourceLine>
   <SourceLine>if result &lt;&gt; 0 then</SourceLine>
   <SourceLine>exit</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>next</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>return result</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>0</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>compare As JSONItem_MTC</ItemParams>
  <ItemResult>Integer</ItemResult>
 </Method>
 <Method>
  <ItemName>CompareValues</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>293853183</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function CompareValues(v1 As Variant, v2 As Variant) As Integer</SourceLine>
   <SourceLine>if v1.IsNull and v2.IsNull then</SourceLine>
   <SourceLine>return 0</SourceLine>
   <SourceLine>elseif v1.IsNull then</SourceLine>
   <SourceLine>return -1</SourceLine>
   <SourceLine>elseif v2.IsNull then</SourceLine>
   <SourceLine>return 1</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>dim result as integer</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if v1 isa JSONItem_MTC and v2 isa JSONItem_MTC then</SourceLine>
   <SourceLine>result = JSONItem_MTC( v1 ).Operator_Compare( JSONItem_MTC( v2 ) )</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>dim type1 as integer = v1.Type</SourceLine>
   <SourceLine>dim type2 as integer = v2.Type</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// Normalize the types</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>if type1 = Variant.TypeInt32 or type1 = Variant.TypeInteger then</SourceLine>
   <SourceLine>type1 = Variant.TypeInt64</SourceLine>
   <SourceLine>elseif type1 = Variant.TypeCurrency then</SourceLine>
   <SourceLine>dim d as double = v1.CurrencyValue</SourceLine>
   <SourceLine>v1 = d</SourceLine>
   <SourceLine>type1 = Variant.TypeDouble </SourceLine>
   <SourceLine>elseif type1 = Variant.TypeSingle then</SourceLine>
   <SourceLine>type1 = Variant.TypeDouble</SourceLine>
   <SourceLine>elseif type1 = Variant.TypeText then</SourceLine>
   <SourceLine>dim s as string = v1.TextValue</SourceLine>
   <SourceLine>v1 = s</SourceLine>
   <SourceLine>type1 = Variant.TypeString</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if type2 = Variant.TypeInt32 or type2 = Variant.TypeInteger then</SourceLine>
   <SourceLine>type2 = Variant.TypeInt64</SourceLine>
   <SourceLine>elseif type2 = Variant.TypeCurrency then</SourceLine>
   <SourceLine>dim d as double = v2.CurrencyValue</SourceLine>
   <SourceLine>v2 = d</SourceLine>
   <SourceLine>type2 = Variant.TypeCurrency</SourceLine>
   <SourceLine>elseif type2 = Variant.TypeSingle then</SourceLine>
   <SourceLine>type2 = Variant.TypeDouble</SourceLine>
   <SourceLine>elseif type2 = Variant.TypeText then</SourceLine>
   <SourceLine>dim s as string = v2.TextValue</SourceLine>
   <SourceLine>v2 = s</SourceLine>
   <SourceLine>type2 = Variant.TypeString</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if type1 = type2 then</SourceLine>
   <SourceLine>select case type1</SourceLine>
   <SourceLine>case Variant.TypeInt64</SourceLine>
   <SourceLine>result = v1.IntegerValue - v1.IntegerValue</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>case Variant.TypeBoolean</SourceLine>
   <SourceLine>if v1.BooleanValue = v2.BooleanValue then</SourceLine>
   <SourceLine>result = 0</SourceLine>
   <SourceLine>elseif v1.BooleanValue then</SourceLine>
   <SourceLine>result = 1</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>result = -1</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>case else // Strings, doubles, singles</SourceLine>
   <SourceLine>result = StrComp( v1.StringValue, v2.StringValue, 0 )</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>end select</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>result = type1 - type2</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>return result</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>v1 As Variant, v2 As Variant</ItemParams>
  <ItemResult>Integer</ItemResult>
 </Method>
 <Note>
  <ItemName>Legal</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>220936191</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <NoteLine>Legal</NoteLine>
   <NoteLine>This class was created by Kem Tekinay, MacTechnologies Consulting (ktekinay@mactechnologies.com).</NoteLine>
   <NoteLine>It is copyright 2015 by Kem Tekinay, all rights reserved.</NoteLine>
   <NoteLine></NoteLine>
   <NoteLine>This project is distributed AS-IS and no warranty of fitness for any particular purpose is expressed or implied.</NoteLine>
   <NoteLine>The author disavows any responsibility for bad design, poor execution, or any other faults.</NoteLine>
   <NoteLine></NoteLine>
   <NoteLine>You may freely use or modify this project or any part within. You may distribute a modified version as long </NoteLine>
   <NoteLine>as this notice or any other legal notice is left undisturbed and all modifications are clearly documented and </NoteLine>
   <NoteLine>accredited. The author does not actively support this class, although comments and recommendations are </NoteLine>
   <NoteLine>welcome.</NoteLine>
   <NoteLine></NoteLine>
  </ItemSource>
  <ItemFlags>0</ItemFlags>
 </Note>
 <Note>
  <ItemName>About</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>2034724863</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <NoteLine>About</NoteLine>
   <NoteLine>JSONItem_MTC</NoteLine>
   <NoteLine></NoteLine>
   <NoteLine>This is a drop-in replacements for the native JSONItem. It emulates all its features but should</NoteLine>
   <NoteLine>perform certain functions faster.</NoteLine>
   <NoteLine></NoteLine>
   <NoteLine>To use it, search for "JSONItem" within your project and replace it with "JSONItem_MTC". Then</NoteLine>
   <NoteLine>drag the JSONItem_MTC class into your project.</NoteLine>
   <NoteLine></NoteLine>
   <NoteLine>Differences:</NoteLine>
   <NoteLine></NoteLine>
   <NoteLine>- You can add any object to JSONItem and it will throw an exception when you try to use ToString.</NoteLine>
   <NoteLine>This class will throw that exception when you try to add the bad object.</NoteLine>
   <NoteLine></NoteLine>
   <NoteLine>- This class has an extra property, EncodeUnicode. By default, it is False to emulate the native class. </NoteLine>
   <NoteLine>If set to True, it will encode all characters whose codepoints are greater than 127.</NoteLine>
   <NoteLine></NoteLine>
   <NoteLine>- Some error messages will be different within this class than the native class.</NoteLine>
   <NoteLine></NoteLine>
   <NoteLine>- As of Xojo 2014r21, ToString is significantly faster in this class than the native version.</NoteLine>
   <NoteLine></NoteLine>
   <NoteLine>See the Legal note for licensing information. If you do make useful modifications, please let me </NoteLine>
   <NoteLine>know so I can include them in future versions.</NoteLine>
   <NoteLine></NoteLine>
   <NoteLine>Kem Tekinay</NoteLine>
   <NoteLine>ktekinay@mactechnologies.com</NoteLine>
   <NoteLine>http://www.mactechnologies.com</NoteLine>
   <NoteLine></NoteLine>
   <NoteLine>Original project at:</NoteLine>
   <NoteLine>https://github.com/ktekinay/JSONItem_MTC</NoteLine>
   <NoteLine></NoteLine>
  </ItemSource>
  <ItemFlags>0</ItemFlags>
 </Note>
 <Note>
  <ItemName>Acknowledgements</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>2077947903</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <NoteLine>Acknowledgements</NoteLine>
   <NoteLine>With thanks to Jeremy Cowgar for his suggestions and adding the unit testing framework.</NoteLine>
   <NoteLine></NoteLine>
   <NoteLine>With thanks for Paul Lefebvre of Xojo, Inc., for creating the unit testing framework in the first place.</NoteLine>
   <NoteLine></NoteLine>
  </ItemSource>
  <ItemFlags>0</ItemFlags>
 </Note>
 <Note>
  <ItemName>Specs (RFC)</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>957755391</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <NoteLine>Specs (RFC)</NoteLine>
   <NoteLine>This class follows the specs in RFC 7159 found, among other places, here:</NoteLine>
   <NoteLine></NoteLine>
   <NoteLine>http://tools.ietf.org/html/rfc7159</NoteLine>
   <NoteLine></NoteLine>
  </ItemSource>
  <ItemFlags>0</ItemFlags>
 </Note>
 <Property>
  <ItemName>ArrayValues()</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>380983295</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>ArrayValues() As Variant</SourceLine>
   <SourceLine></SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <ItemDeclaration>ArrayValues() As Variant</ItemDeclaration>
  <ItemFlags>1</ItemFlags>
  <IsShared>0</IsShared>
 </Property>
 <Property>
  <ItemName>Compact</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>1741629439</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Compact As Boolean = True</SourceLine>
   <SourceLine></SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <ItemDeclaration>Compact As Boolean = True</ItemDeclaration>
  <ItemFlags>0</ItemFlags>
  <IsShared>0</IsShared>
 </Property>
 <Property>
  <ItemName>DecimalFormat</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>1761923071</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>DecimalFormat As String</SourceLine>
   <SourceLine></SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <ItemDeclaration>DecimalFormat As String</ItemDeclaration>
  <ItemFlags>0</ItemFlags>
  <IsShared>0</IsShared>
 </Property>
 <Property>
  <ItemName>EscapeSlashes</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>1982945279</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>EscapeSlashes As Boolean = True</SourceLine>
   <SourceLine></SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <ItemDeclaration>EscapeSlashes As Boolean = True</ItemDeclaration>
  <ItemFlags>0</ItemFlags>
  <IsShared>0</IsShared>
 </Property>
 <Property>
  <ItemName>HasSetType</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>1829965823</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>HasSetType As Integer</SourceLine>
   <SourceLine></SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <ItemDeclaration>HasSetType As Integer</ItemDeclaration>
  <ItemFlags>1</ItemFlags>
  <IsShared>0</IsShared>
 </Property>
 <Property>
  <ItemName>IndentSpacing</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>991193087</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>IndentSpacing As Integer = 2</SourceLine>
   <SourceLine></SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <ItemDeclaration>IndentSpacing As Integer = 2</ItemDeclaration>
  <ItemFlags>0</ItemFlags>
  <IsShared>0</IsShared>
 </Property>
 <Property>
  <ItemName>IsArray</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>877072383</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>IsArray As Boolean</SourceLine>
   <SourceLine></SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <ItemDeclaration>IsArray As Boolean</ItemDeclaration>
  <ItemFlags>0</ItemFlags>
  <IsShared>0</IsShared>
  <SetAccessor>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Set</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Set</SourceLine>
  </SetAccessor>
  <GetAccessor>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Get</SourceLine>
   <SourceLine>return HasSetType = kHasSetArray</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Get</SourceLine>
  </GetAccessor>
 </Property>
 <Property>
  <ItemName>IsObject</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>1241823231</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>IsObject As Boolean</SourceLine>
   <SourceLine></SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <ItemDeclaration>IsObject As Boolean</ItemDeclaration>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <SetAccessor>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Set</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Set</SourceLine>
  </SetAccessor>
  <GetAccessor>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Get</SourceLine>
   <SourceLine>return HasSetType = kHasSetObject</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Get</SourceLine>
  </GetAccessor>
 </Property>
 <Property>
  <ItemName>ObjectValues</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>183478271</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>ObjectValues As Dictionary</SourceLine>
   <SourceLine></SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <ItemDeclaration>ObjectValues As Dictionary</ItemDeclaration>
  <ItemFlags>1</ItemFlags>
  <IsShared>0</IsShared>
 </Property>
 <Property>
  <ItemName>EncodeUnicode</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>1680922623</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>EncodeUnicode As EncodeType = EncodeType.JavaScriptCompatible</SourceLine>
   <SourceLine></SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <ItemDeclaration>EncodeUnicode As EncodeType = EncodeType.JavaScriptCompatible</ItemDeclaration>
  <ItemFlags>0</ItemFlags>
  <IsShared>0</IsShared>
 </Property>
 <Property>
  <ItemName>Count</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>1905690623</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Count As Integer</SourceLine>
   <SourceLine></SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <ItemDeclaration>Count As Integer</ItemDeclaration>
  <ItemFlags>0</ItemFlags>
  <IsShared>0</IsShared>
  <SetAccessor>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Set</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Set</SourceLine>
  </SetAccessor>
  <GetAccessor>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Get</SourceLine>
   <SourceLine>if IsArray then</SourceLine>
   <SourceLine>return ArrayValues.Ubound + 1</SourceLine>
   <SourceLine>elseif ObjectValues &lt;&gt; nil then</SourceLine>
   <SourceLine>return ObjectValues.Count</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>return 0</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Get</SourceLine>
  </GetAccessor>
 </Property>
 <Property>
  <ItemName>Strict</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>1549398015</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Strict As Boolean</SourceLine>
   <SourceLine></SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <ItemDeclaration>Strict As Boolean</ItemDeclaration>
  <ItemFlags>0</ItemFlags>
  <IsShared>0</IsShared>
 </Property>
 <Property>
  <ItemName>LoadCS</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>1467363327</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>LoadCS As CriticalSection</SourceLine>
   <SourceLine></SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <ItemDeclaration>LoadCS As CriticalSection</ItemDeclaration>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
 </Property>
 <Property>
  <ItemName>mIsLoading</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>813780991</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>mIsLoading As Boolean</SourceLine>
   <SourceLine></SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <ItemDeclaration>mIsLoading As Boolean</ItemDeclaration>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
 </Property>
 <Property>
  <ItemName>ToString</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>31318015</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>ToString As String</SourceLine>
   <SourceLine></SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <ItemDeclaration>ToString As String</ItemDeclaration>
  <ItemFlags>0</ItemFlags>
  <IsShared>0</IsShared>
  <SetAccessor>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Set</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Set</SourceLine>
  </SetAccessor>
  <GetAccessor>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Get</SourceLine>
   <SourceLine>return self.Serialize( self )</SourceLine>
   <SourceLine>End Get</SourceLine>
  </GetAccessor>
 </Property>
 <Property>
  <ItemName>ToNativeValue</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>659066879</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>ToNativeValue As Variant</SourceLine>
   <SourceLine></SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <ItemDeclaration>ToNativeValue As Variant</ItemDeclaration>
  <ItemFlags>0</ItemFlags>
  <IsShared>0</IsShared>
  <SetAccessor>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Set</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Set</SourceLine>
  </SetAccessor>
  <GetAccessor>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Get</SourceLine>
   <SourceLine>if IsObject then</SourceLine>
   <SourceLine>dim d as Dictionary = new Dictionary</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>dim rawKeys() as variant = ObjectValues.Keys</SourceLine>
   <SourceLine>dim values() as variant = ObjectValues.Values</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>for i as integer = 0 to rawKeys.Ubound</SourceLine>
   <SourceLine>dim name as string = KeyToName( rawKeys( i ) )</SourceLine>
   <SourceLine>dim value as variant = values( i )</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if value isa JSONItem_MTC then</SourceLine>
   <SourceLine>value = JSONItem_MTC( value ).ToNativeValue</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>d.Value( name ) = value</SourceLine>
   <SourceLine>next</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>return d</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>elseif IsArray then</SourceLine>
   <SourceLine>dim arr() as variant</SourceLine>
   <SourceLine>redim arr( ArrayValues.Ubound )</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>for i as integer = 0 to ArrayValues.Ubound</SourceLine>
   <SourceLine>dim value as variant = ArrayValues( i )</SourceLine>
   <SourceLine>if value isa JSONItem_MTC then</SourceLine>
   <SourceLine>value = JSONItem_MTC( value ).ToNativeValue</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>arr( i ) = value</SourceLine>
   <SourceLine>next</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>return arr</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>return nil</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>End Get</SourceLine>
  </GetAccessor>
 </Property>
 <ViewBehavior>
  <ViewProperty>
   <ObjName>Compact</ObjName>
   <PropertyGroup>Behavior</PropertyGroup>
   <PropertyValue>True</PropertyValue>
   <ItemType>Boolean</ItemType>
  </ViewProperty>
  <ViewProperty>
   <ObjName>DecimalFormat</ObjName>
   <PropertyGroup>Behavior</PropertyGroup>
   <PropertyValue>-0.0##############</PropertyValue>
   <ItemType>String</ItemType>
   <EditorType>MultiLineEditor</EditorType>
  </ViewProperty>
  <ViewProperty>
   <ObjName>EscapeSlashes</ObjName>
   <PropertyGroup>Behavior</PropertyGroup>
   <PropertyValue>True</PropertyValue>
   <ItemType>Boolean</ItemType>
  </ViewProperty>
  <ViewProperty>
   <ObjName>IndentSpacing</ObjName>
   <PropertyGroup>Behavior</PropertyGroup>
   <PropertyValue>2</PropertyValue>
   <ItemType>Integer</ItemType>
  </ViewProperty>
  <ViewProperty>
   <ObjName>Index</ObjName>
   <Visible>1</Visible>
   <PropertyGroup>ID</PropertyGroup>
   <PropertyValue>-2147483648</PropertyValue>
   <ItemType>Integer</ItemType>
  </ViewProperty>
  <ViewProperty>
   <ObjName>IsArray</ObjName>
   <PropertyGroup>Behavior</PropertyGroup>
   <ItemType>Boolean</ItemType>
  </ViewProperty>
  <ViewProperty>
   <ObjName>Left</ObjName>
   <Visible>1</Visible>
   <PropertyGroup>Position</PropertyGroup>
   <PropertyValue>0</PropertyValue>
   <ItemType>Integer</ItemType>
  </ViewProperty>
  <ViewProperty>
   <ObjName>Name</ObjName>
   <Visible>1</Visible>
   <PropertyGroup>ID</PropertyGroup>
   <ItemType>String</ItemType>
  </ViewProperty>
  <ViewProperty>
   <ObjName>Super</ObjName>
   <Visible>1</Visible>
   <PropertyGroup>ID</PropertyGroup>
   <ItemType>String</ItemType>
  </ViewProperty>
  <ViewProperty>
   <ObjName>Top</ObjName>
   <Visible>1</Visible>
   <PropertyGroup>Position</PropertyGroup>
   <PropertyValue>0</PropertyValue>
   <ItemType>Integer</ItemType>
  </ViewProperty>
  <ViewProperty>
   <ObjName>Count</ObjName>
   <PropertyGroup>Behavior</PropertyGroup>
   <ItemType>Integer</ItemType>
  </ViewProperty>
  <ViewProperty>
   <ObjName>Strict</ObjName>
   <PropertyGroup>Behavior</PropertyGroup>
   <ItemType>Boolean</ItemType>
  </ViewProperty>
  <ViewProperty>
   <ObjName>ToString</ObjName>
   <PropertyGroup>Behavior</PropertyGroup>
   <ItemType>String</ItemType>
   <EditorType>MultiLineEditor</EditorType>
  </ViewProperty>
  <ViewProperty>
   <ObjName>EncodeUnicode</ObjName>
   <PropertyGroup>Behavior</PropertyGroup>
   <PropertyValue>EncodeType.JavaScriptCompatible</PropertyValue>
   <ItemType>EncodeType</ItemType>
   <EditorType>Enum</EditorType>
   <Enumeration>
    <ItemDef>0 - None</ItemDef>
    <ItemDef>1 - JavaScriptCompatible</ItemDef>
    <ItemDef>2 - All</ItemDef>
   </Enumeration>
  </ViewProperty>
 </ViewBehavior>
 <Constant>
  <ItemName>kBackSlash</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>763668479</PartID>
  <TextEncoding>134217984</TextEncoding>
  <ItemType>2</ItemType>
  <ItemDef>92</ItemDef>
  <ItemFlags>33</ItemFlags>
 </Constant>
 <Constant>
  <ItemName>kCloseCurlyBrace</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>1277224959</PartID>
  <TextEncoding>134217984</TextEncoding>
  <ItemType>2</ItemType>
  <ItemDef>125</ItemDef>
  <ItemFlags>33</ItemFlags>
 </Constant>
 <Constant>
  <ItemName>kCloseSquareBracket</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>1223139327</PartID>
  <TextEncoding>134217984</TextEncoding>
  <ItemType>2</ItemType>
  <ItemDef>93</ItemDef>
  <ItemFlags>33</ItemFlags>
 </Constant>
 <Constant>
  <ItemName>kColon</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>884340735</PartID>
  <TextEncoding>134217984</TextEncoding>
  <ItemType>2</ItemType>
  <ItemDef>58</ItemDef>
  <ItemFlags>33</ItemFlags>
 </Constant>
 <Constant>
  <ItemName>kComma</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>1194700799</PartID>
  <TextEncoding>134217984</TextEncoding>
  <ItemType>2</ItemType>
  <ItemDef>44</ItemDef>
  <ItemFlags>33</ItemFlags>
 </Constant>
 <Constant>
  <ItemName>kForwardSlash</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>1722542079</PartID>
  <TextEncoding>134217984</TextEncoding>
  <ItemType>2</ItemType>
  <ItemDef>47</ItemDef>
  <ItemFlags>33</ItemFlags>
 </Constant>
 <Constant>
  <ItemName>kHasSetArray</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>961742847</PartID>
  <TextEncoding>134217984</TextEncoding>
  <ItemType>2</ItemType>
  <ItemDef>1</ItemDef>
  <ItemFlags>33</ItemFlags>
 </Constant>
 <Constant>
  <ItemName>kHasSetNone</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>545648639</PartID>
  <TextEncoding>134217984</TextEncoding>
  <ItemType>2</ItemType>
  <ItemDef>0</ItemDef>
  <ItemFlags>33</ItemFlags>
 </Constant>
 <Constant>
  <ItemName>kHasSetObject</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>1818718207</PartID>
  <TextEncoding>134217984</TextEncoding>
  <ItemType>2</ItemType>
  <ItemDef>2</ItemDef>
  <ItemFlags>33</ItemFlags>
 </Constant>
 <Constant>
  <ItemName>kOpenCurlyBrace</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>216090623</PartID>
  <TextEncoding>134217984</TextEncoding>
  <ItemType>2</ItemType>
  <ItemDef>123</ItemDef>
  <ItemFlags>33</ItemFlags>
 </Constant>
 <Constant>
  <ItemName>kOpenSquareBracket</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>1391450111</PartID>
  <TextEncoding>134217984</TextEncoding>
  <ItemType>2</ItemType>
  <ItemDef>91</ItemDef>
  <ItemFlags>33</ItemFlags>
 </Constant>
 <Constant>
  <ItemName>kQuote</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>1988024319</PartID>
  <TextEncoding>134217984</TextEncoding>
  <ItemType>2</ItemType>
  <ItemDef>34</ItemDef>
  <ItemFlags>33</ItemFlags>
 </Constant>
 <Constant>
  <ItemName>Version</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>1097842687</PartID>
  <TextEncoding>134217984</TextEncoding>
  <ItemType>0</ItemType>
  <ItemDef>4.2</ItemDef>
  <ItemFlags>0</ItemFlags>
 </Constant>
 <Constant>
  <ItemName>kHyphen</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>1902444543</PartID>
  <TextEncoding>134217984</TextEncoding>
  <ItemType>2</ItemType>
  <ItemDef>45</ItemDef>
  <ItemFlags>33</ItemFlags>
 </Constant>
 <Constant>
  <ItemName>kPlus</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>547260415</PartID>
  <TextEncoding>134217984</TextEncoding>
  <ItemType>2</ItemType>
  <ItemDef>43</ItemDef>
  <ItemFlags>33</ItemFlags>
 </Constant>
 <Constant>
  <ItemName>kDot</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>217178111</PartID>
  <TextEncoding>134217984</TextEncoding>
  <ItemType>2</ItemType>
  <ItemDef>46</ItemDef>
  <ItemFlags>33</ItemFlags>
 </Constant>
 <Constant>
  <ItemName>kDefaultDecimalFormat</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>1628862463</PartID>
  <TextEncoding>134217984</TextEncoding>
  <ItemType>0</ItemType>
  <ItemDef>-0.0##############</ItemDef>
  <ItemFlags>0</ItemFlags>
 </Constant>
 <Constant>
  <ItemName>kInMBSize</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>1991727103</PartID>
  <TextEncoding>134217984</TextEncoding>
  <ItemType>2</ItemType>
  <ItemDef>2048</ItemDef>
  <ItemFlags>33</ItemFlags>
 </Constant>
 <Constant>
  <ItemName>kOutMBSize</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>322291711</PartID>
  <TextEncoding>134217984</TextEncoding>
  <ItemType>2</ItemType>
  <ItemDef>2097152</ItemDef>
  <ItemFlags>33</ItemFlags>
 </Constant>
 <Enumeration>
  <TextEncoding>134217984</TextEncoding>
  <ItemName>EncodeType</ItemName>
  <ItemFlags>0</ItemFlags>
  <ItemType>Integer</ItemType>
  <ItemName>EncodeType</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>619845631</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>None = 0</SourceLine>
   <SourceLine>JavaScriptCompatible = 1</SourceLine>
   <SourceLine>All = 2</SourceLine>
  </ItemSource>
 </Enumeration>
</block>
</RBProject>
